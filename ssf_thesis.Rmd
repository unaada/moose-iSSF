---
title: "ssf_thesis"
author: "Una Adamoviča"
date: "2025-03-05"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(suncalc)
library(chron)

library(sf)
library(terra)
library(tidyverse)
library(lubridate)
library(corrplot)

library(amt)
library(glmmTMB)

```


```{r workflow}

### collect covariates
# distance to road per class
# land cover: different forest types, open, anthropogenic, water, new forest
# time of day:distance_to_road and time:crossing(y/n)
# season - after decding which models, then build for 3 seasons?
# -- perhaps -- make also the angle analysis = avoidance, attraction, corridor



```



```{r preperation of moose data, echo=TRUE}

moose <- read.csv("moose_df.csv")

# clean and make tracks 
moose <- moose %>% 
  mutate(timestamp = as.POSIXct(as.character(timestamp),  format = "%Y-%m-%d %H:%M:%S")) %>%
  filter(!is.na(timestamp)) %>% 
  make_track(UTM.Easting, UTM.Northing, timestamp, crs = 3301, id = id)

head(moose, 5)

# # A tibble: 5 × 4
#        x_       y_ t_                     id
# *   <dbl>    <dbl> <dttm>              <int>
# 1 591225. 6545176. 2018-11-23 22:30:18 39789
# 2 591250. 6545167. 2018-11-23 23:00:08 39789
# 3 591337. 6545008. 2018-11-23 23:30:16 39789
# 4 591292. 6544921. 2018-11-24 00:00:11 39789
# 5 591238. 6545135. 2018-11-24 00:30:30 39789

summarize_sampling_rate_many(moose, "id")

# make manipulations of moose data
moose_sf <- st_as_sf(moose, coords = c("x_", "y_"), crs = 3301) 

# create lines
moose_lines <- moose_sf %>%
  group_by(id) %>%
  summarize(do_union = FALSE) %>%
  st_cast("LINESTRING")
plot(moose_lines)

# create study area to clip everyhting
study_area <- moose_sf %>%
  st_buffer(dist = 1823) %>%
  st_union() %>%
  st_as_sf()

# remove the points when animals are resting
points_to_keep <- moose_sf %>%
  group_by(id) %>%
  mutate(
    distance = as.numeric(st_distance(geometry, lead(geometry), by_element = TRUE)),
    keep_point = !is.na(distance) & distance > 18
  ) %>%
  pull(keep_point)

moose_filter <- moose[points_to_keep, ]
head(moose_filter, 5)

# > head(moose_filter, 5)
# # A tibble: 5 × 4
#        x_       y_ t_                     id
# *   <dbl>    <dbl> <dttm>              <int>
# 1 591225. 6545176. 2018-11-23 22:30:18 39789
# 2 591250. 6545167. 2018-11-23 23:00:08 39789
# 3 591337. 6545008. 2018-11-23 23:30:16 39789
# 4 591292. 6544921. 2018-11-24 00:00:11 39789
# 5 591238. 6545131. 2018-11-24 03:00:15 39789

# list-column to make it easy to apply functions to each animal data seperately 
dat1 <- moose_filter %>% nest(data = -id)
head(dat1,8)

# > head(dat1,8)
# # A tibble: 8 × 2
#      id data                  
#   <int> <list>                
# 1 39789 <trck_xyt [4,548 × 3]>
# 2 39787 <trck_xyt [6,073 × 3]>
# 3 39785 <trck_xyt [5,870 × 3]>
# 4 39788 <trck_xyt [5,140 × 3]>
# 5 39793 <trck_xyt [5,894 × 3]>
# 6 39791 <trck_xyt [5,780 × 3]>
# 7 39790 <trck_xyt [5,464 × 3]>
# 8 39794 <trck_xyt [6,430 × 3]>

# resample to have everything consistent
dat2 <- dat1 %>% 
  mutate(dat.resample = map(data, ~ track_resample(., 
                                                   rate = lubridate::minutes(30), 
                                                   tolerance = lubridate::minutes(4)))) 

head(dat2)

# id
# <int>
# data
# <list>
# dat.resample
# <list>
# 39789	<S3: track_xyt>	<S3: track_xyt>		
# 39787	<S3: track_xyt>	<S3: track_xyt>		
# 39785	<S3: track_xyt>	<S3: track_xyt>		
# 39788	<S3: track_xyt>	<S3: track_xyt>		
# 39793	<S3: track_xyt>	<S3: track_xyt>		
# 39791	<S3: track_xyt>	<S3: track_xyt>	

# ----------- sample period ------------

# sample period for each moose
time_summary <- moose %>%
  group_by(id) %>%
  summarize(
    start_date = format(min(t_), "%Y/%m/%d"),
    end_date = format(max(t_), "%Y/%m/%d"),
    sample_period = paste(start_date, "–", end_date)
  )

total_steps <- moose %>%
  group_by(id) %>%
  summarize(actual_steps = n())

active_steps <- moose_filter %>%
  group_by(id) %>%
  summarize(active_steps = n())

# combine all information
result_table <- time_summary %>%
  left_join(total_steps, by = "id") %>%
  left_join(active_steps, by = "id") %>%
  mutate(
    inactive_steps = actual_steps - active_steps,
  ) %>%
  dplyr::select(id, sample_period, actual_steps, active_steps, inactive_steps)

formatted_table <- result_table %>%
  rename(`Individual Id` = id,
         `Sample Period` = sample_period,
         `Number of actual steps` = actual_steps,
         `Number of active steps` = active_steps,
         `Number of inactive steps` = inactive_steps)

formatted_table


```


```{r collecting covariates}
#layers

new_forest <- rast("D:\\Users\\amand\\Documents\\qgis\\masters_data\\Hansen_GFC-2022-v1.10_lossyear_60N_020E.tif")

roads <- st_read("D:\\Users\\amand\\Documents\\qgis\\masters_qgis\\vectors\\full-road-classes.gpkg")

corine <- rast("D:\\Users\\amand\\Documents\\qgis\\masters_qgis\\rasters\\corine_30m_resample_mode.tif")

slope <- rast("D:\\Users\\amand\\Documents\\qgis\\masters_qgis\\rasters\\slope_30m_degrees.tif")

#### 1. landuse
# reclassify matrix to group landuse categories
m <- matrix(c(0,22,1,
              22,23, 2,
              23, 24, 3,
              24, 25, 4,
              25, 41, 5), ncol = 3, byrow = TRUE)

# 1 = human-modified = agriculture and anthropogenic
# 2 = broad-leaved (deciduous)
# 3 = coniferous
# 4 = mixed
# 5 = open areas -> combine with srub and peatbog and water
# lowest excluded, maximum included

landuse <- terra::classify(corine, m) %>%
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("landuse")

#### 2. roads + distance
# distance to roads code
  # mutate(
  #   nearest_major = st_distance(geometry,st_union(roads[roads$class>= 2, ])),
  #   nearest_minor = st_distance(geometry, st_union(roads[roads$class== 1, ])),
  #   nearest_local = st_distance(geometry, st_union(roads[roads$class == 0, ]))
  # )

major_roads_dist <- roads[roads$class >= 2,] %>%
  rasterize(landuse) %>%
  distance() %>% 
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("major_d")

minor_roads_dist <- roads[roads$class == 1,] %>%
  rasterize(landuse) %>%
  distance() %>% 
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("minor_d")

local_roads_dist <- roads[roads$class == 0,] %>%
  rasterize(landuse) %>%
  distance() %>% 
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("local_d")


#### 3. new forest (forest loss)
# reproject the layer, align the grids, and assign binary values to have new forest y/n
new_forest <- new_forest %>% 
  project(landuse) %>% 
  resample(landuse, method = "near") %>% 
  classify(matrix(c(3, 16, 1,
                    16, 22, 0), ncol = 3, byrow = TRUE)) %>% 
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("new_forest")

# where new forest is 
mask_new_forest <- new_forest == 1

landuse_in_newforest <- mask(landuse, mask_new_forest)

freq_table <- terra::freq(landuse_in_newforest)
total_pixels <- sum(freq_table$count, na.rm = TRUE)
freq_table$percentage <- (freq_table$count / total_pixels) * 100

# > freq_table
#   layer value  count percentage
# 1     1     1 123684  24.021255
# 2     1     2  11752   2.282412
# 3     1     3 126907  24.647209
# 4     1     4 130521  25.349101
# 5     1     5 122030  23.700024

# where forest is in landuse
forest_types <- landuse %in% c(2, 3, 4, 5)
forest_to_override <- forest_types & mask_new_forest

landuse_total <- landuse %>% 
  setNames("landuse_total")
landuse_total[forest_to_override] <- 6

freq_before <- terra::freq(landuse)
freq_after <- terra::freq(landuse_total)
print(data.frame(
  Category = c("Human-modified", "Deciduous", "Coniferous", "Mixed", "Open/shrub/bog", "New forest"),
  Before = c(freq_before$count, 0),  # Add 0 for the new category that didn't exist before
  After = freq_after$count
))

#### 4. slope

slope <- slope %>%
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("slope")



```


```{r all moose}

# remove for each moose if burst < 3
dat3 <- dat2 %>%
  mutate(dat.filtered = map(dat.resample, ~ filter_min_n_burst(., min_n = 3)))
# try to retain the filtered AND the id columns
all_moose <- map2_dfr(dat3$dat.filtered, dat3$id, ~{
  .x %>% mutate(id = .y)
})
# again it wants to remove the id, so make map
burst_id_map <- as.data.frame(all_moose) %>%
  dplyr::select(id, burst_) %>%
  distinct()

set.seed(12345) 
# regular generation of steps
steps <- all_moose %>%
  steps_by_burst() %>%
  random_steps(n_control = 10, 
              sl_distr = fit_distr(.$sl_, "gamma"),
              ta_distr = fit_distr(.$ta_, "vonmises"), 
              include_observed = TRUE) %>% 
  remove_incomplete_strata()

# try to join back the moose id to have for glmmm as random effect
steps <- steps %>%
  left_join(burst_id_map, by = "burst_", relationship = "many-to-one", multiple = "first")

# get the covariates for each step
steps2 <- steps %>% 
  extract_covariates(landuse_total) %>% 
  extract_covariates(major_roads_dist) %>%
  extract_covariates(minor_roads_dist) %>%
  extract_covariates(local_roads_dist) %>% 
  extract_covariates(slope)


#  time categories
steps2 <- steps2 %>%
  mutate(
    time_of_day = chron(times = format(t1_, format = "%H:%M:%S")),
    date = as.Date(t1_, format = "%Y/%m/%d")
  ) 

# get time of day times to assign time categories
sunlight <- getSunlightTimes(
  date = steps2$date,
  lon = 25.45, 
  lat = 59.05, 
  keep = c("sunrise", "sunset", "dawn", "dusk"),
  tz = "Europe/Tallinn"
)

steps3 <- steps2 %>%
  # join to get the time of sunglight for each observation
  left_join(sunlight, by = "date", relationship = "many-to-many", multiple = "first") %>%
  
  # assign time category for each observation based on sunlight availability
  mutate(
    sunrise = chron(times = format(sunrise, format = "%H:%M:%S")),
    sunset = chron(times = format(sunset, format = "%H:%M:%S")),
    dawn = chron(times = format(dawn, format = "%H:%M:%S")),
    dusk = chron(times = format(dusk, format = "%H:%M:%S")),
    
    time_category = case_when(
      time_of_day >= sunrise & time_of_day < sunset ~ "Day", # day
      (time_of_day >= dawn & time_of_day < sunrise) | 
        (time_of_day >= sunset & time_of_day < dusk) ~ "Twilight", # twilight
      TRUE ~ "Night"), #night
    
    month = lubridate::month(t1_, label = TRUE),
    
    # assign season category
    season = case_when(
      month %in% c("Nov","Dec", "Jan", "Feb","Mar") ~ "Winter", #winter
      month %in% c( "Apr", "May") ~ "Spring", #spring
      month %in% c("Jun", "Jul", "Aug", "Sep") ~ "Summer" #summer
    ),
    
    # insert state road distances (major + minor class) 
    state_d = pmin(minor_d, major_d, na.rm = TRUE)

  ) %>%
  
  # remove some unnecessary attributes
  dplyr::select(-sunrise, -sunset, -dawn, -dusk, -lon, -lat)


# steffanie suggestion how to structure data for injection
d.map <- data.frame(step_id_=unique(steps3$step_id_), 
                    str_ID=1:length(unique(steps3$step_id_)))

# put new sequential stratum ID
steps3$str_ID <- d.map[match(steps3$step_id_, d.map$step_id_), "str_ID"]

# ordering data by stratum id
steps3 <- steps3[order(steps3$str_ID),]

# give meaningful names and give reference category
steps3$landuse_factor <- factor(steps3$landuse_total,
                                labels = c("Human-modified", "Deciduous",
                                           "Coniferous", "Mixed", "Open/shrub/bog", "New forest")) %>% 
  relevel(ref = "Coniferous")

# 1 = human-modified = agriculture and anthropogenic
# 2 = broad-leaved (deciduous)
# 3 = coniferous
# 4 = mixed
# 5 = open areas -> combine with shrub and peatbog and water
# 6 = new forest 

# change reference category
steps3$time_category <- factor(steps3$time_category) %>% relevel(ref = "Day")
steps3$season <- factor(steps3$season) %>% relevel(ref = "Summer")

# create an original (before scaling) variable
steps3_original <- steps3

steps3$s_sl_ <- scale(steps3$sl_)
steps3$s_ta_ <- scale(cos(steps3$ta_))
steps3$s_minor_d <- scale(steps3$minor_d)
steps3$s_major_d <- scale(steps3$major_d)
steps3$s_local_d <- scale(steps3$local_d)
steps3$s_state_d <- scale(steps3$state_d)
steps3$s_slope <- scale(steps3$slope)

```



```{r base movement model}

#----------------------------------------------------- glmm ----------------------------------------------------

# Define GLMM structure without fitting
TMBStruc1 <- glmmTMB(
  num_case_ ~ s_sl_ + s_ta_ + s_slope +
    s_minor_d + s_major_d + s_local_d + 
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

# put variance 1e3, so SD would be 1e6
TMBStruc1$parameters$theta[1] = log(1e3)  

# assign that the variance would not be estimated for the first random effect 
TMBStruc1$mapArg = list(theta = factor(c(NA, 1)))

# now finally fit the model
model_glmm1 <- glmmTMB:::fitTMB(TMBStruc1)

summary(model_glmm1)


# ---- basic with 2 road categories -------

TMBStruc1.1 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_ta_ +
    s_state_d + s_local_d + s_slope +
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc1.1$parameters$theta[1] = log(1e3)  
TMBStruc1.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm1.1 <- glmmTMB:::fitTMB(TMBStruc1.1)
summary(model_glmm1.1)



# ----------------------------------------- basic with 2 road categories -1 -------------------------

#pls check what to remove
TMBStruc1.1.1 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_ta_ +
    s_state_d + s_local_d + s_slope +
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc1.1.1$parameters$theta[1] = log(1e3)  
TMBStruc1.1.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm1.1.1 <- glmmTMB:::fitTMB(TMBStruc1.1.1)
summary(model_glmm1.1.1)



# --- landuse local -----

TMBStruc_local <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_ta_ + s_slope +
    s_local_d +
    landuse_factor + s_local_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_local$parameters$theta[1] = log(1e3)  
TMBStruc_local$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_local <- glmmTMB:::fitTMB(TMBStruc_local)
summary(model_glmm_local)


#       AIC       BIC    logLik  deviance  df.resid 
#  404788.6  404953.1 -202378.3  404756.6    216420 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 2.392e-05 4.891e-03
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                         Estimate Std. Error z value Pr(>|z|)    
# s_sl_                                   0.131862   0.006678  19.747  < 2e-16 ***
# s_ta_                                   0.004546   0.007517   0.605  0.54536    
# s_slope                                -0.009452   0.009670  -0.977  0.32834    
# s_local_d                               0.048188   0.028617   1.684  0.09220 .  
# landuse_factorConiferous               -3.001944   7.129086  -0.421  0.67369    
# landuse_factorHuman-modified           -3.257871   7.129369  -0.457  0.64770    
# landuse_factorDeciduous                -2.817324   7.129244  -0.395  0.69271    
# landuse_factorMixed                    -2.969922   7.129087  -0.417  0.67698    
# landuse_factorOpen/shrub/bog           -2.972250   7.129121  -0.417  0.67674    
# landuse_factorNew forest               -2.644663   7.129073  -0.371  0.71066    
# s_local_d:landuse_factorHuman-modified  0.125323   0.074469   1.683  0.09240 .  
# s_local_d:landuse_factorDeciduous       0.138984   0.050534   2.750  0.00595 ** 
# s_local_d:landuse_factorMixed           0.070756   0.033245   2.128  0.03331 *  
# s_local_d:landuse_factorOpen/shrub/bog  0.009372   0.032859   0.285  0.77547    
# s_local_d:landuse_factorNew forest      0.027141   0.028062   0.967  0.33345   



# remove ta_ significant 

TMBStruc_local.1 <- glmmTMB(
  num_case_ ~ s_sl_ + s_slope +
    s_local_d +
    landuse_factor + s_local_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_local.1$parameters$theta[1] = log(1e3)  
TMBStruc_local.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_local.1 <- glmmTMB:::fitTMB(TMBStruc_local.1)
summary(model_glmm_local.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404786.9  404941.2 -202378.5  404756.9    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance Std.Dev. 
#  str_ID (Intercept) 1.00e+06 1000.0000
#  id     (Intercept) 1.47e-01    0.3834
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                         Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                            -3.048648   7.132131  -0.427 0.669050    
# s_sl_                                   0.131926   0.006677  19.759  < 2e-16 ***
# s_slope                                -0.009368   0.009667  -0.969 0.332535    
# s_local_d                               0.047722   0.028596   1.669 0.095155 .  
# landuse_factorHuman-modified           -0.255143   0.071291  -3.579 0.000345 ***
# landuse_factorDeciduous                 0.184688   0.057649   3.204 0.001357 ** 
# landuse_factorMixed                     0.032077   0.033222   0.966 0.334272    
# landuse_factorOpen/shrub/bog            0.029870   0.039391   0.758 0.448278    
# landuse_factorNew forest                0.357443   0.027616  12.944  < 2e-16 ***
# s_local_d:landuse_factorHuman-modified  0.125067   0.074451   1.680 0.092984 .  
# s_local_d:landuse_factorDeciduous       0.138967   0.050526   2.750 0.005952 ** 
# s_local_d:landuse_factorMixed           0.070726   0.033240   2.128 0.033357 *  
# s_local_d:landuse_factorOpen/shrub/bog  0.009507   0.032853   0.289 0.772302    
# s_local_d:landuse_factorNew forest      0.027093   0.028058   0.966 0.334241  

# remove slope  

TMBStruc_local.2 <- glmmTMB(
  num_case_ ~ s_sl_ +
    s_local_d +
    landuse_factor + s_local_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_local.2$parameters$theta[1] = log(1e3)  
TMBStruc_local.2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_local.2 <- glmmTMB:::fitTMB(TMBStruc_local.2)
summary(model_glmm_local.2)

#       AIC       BIC    logLik  deviance  df.resid 
#  404785.9  404929.9 -202378.9  404757.9    216422 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.456e-01    0.3816
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                         Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                            -3.054098   7.132104  -0.428 0.668492    
# s_sl_                                   0.131924   0.006677  19.759  < 2e-16 ***
# s_local_d                               0.049407   0.028544   1.731 0.083467 .  
# landuse_factorHuman-modified           -0.259577   0.071123  -3.650 0.000263 ***
# landuse_factorDeciduous                 0.183080   0.057632   3.177 0.001489 ** 
# landuse_factorMixed                     0.031115   0.033208   0.937 0.348765    
# landuse_factorOpen/shrub/bog            0.029302   0.039388   0.744 0.456909    
# landuse_factorNew forest                0.355953   0.027575  12.908  < 2e-16 ***
# s_local_d:landuse_factorHuman-modified  0.125087   0.074419   1.681 0.092791 .  
# s_local_d:landuse_factorDeciduous       0.138424   0.050531   2.739 0.006155 ** 
# s_local_d:landuse_factorMixed           0.070923   0.033236   2.134 0.032849 *  
# s_local_d:landuse_factorOpen/shrub/bog  0.009228   0.032853   0.281 0.778788    
# s_local_d:landuse_factorNew forest      0.026791   0.028055   0.955 0.339601 


# ---- landuse state -----

TMBStruc_state<- glmmTMB(
  num_case_ ~ -1 +  s_sl_ + s_ta_ + s_slope +
    s_state_d +
    landuse_factor + s_state_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_state$parameters$theta[1] = log(1e3)  
TMBStruc_state$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_state <- glmmTMB:::fitTMB(TMBStruc_state)
summary(model_glmm_state)

#       AIC       BIC    logLik  deviance  df.resid 
#  404719.2  404883.8 -202343.6  404687.2    216420 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 2.943e-05 5.425e-03
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                         Estimate Std. Error z value Pr(>|z|)    
# s_sl_                                   0.132994   0.006690  19.878  < 2e-16 ***
# s_ta_                                   0.005011   0.007519   0.666  0.50512    
# s_slope                                -0.007560   0.009677  -0.781  0.43468    
# s_state_d                               0.369134   0.079529   4.642 3.46e-06 ***
# landuse_factorConiferous               -3.012164   7.129078  -0.423  0.67265    
# landuse_factorHuman-modified           -3.319284   7.129150  -0.466  0.64151    
# landuse_factorDeciduous                -2.708073   7.129252  -0.380  0.70405    
# landuse_factorMixed                    -2.970496   7.129079  -0.417  0.67692    
# landuse_factorOpen/shrub/bog           -2.959725   7.129113  -0.415  0.67802    
# landuse_factorNew forest               -2.648850   7.129064  -0.372  0.71022    
# s_state_d:landuse_factorHuman-modified  0.214065   0.041918   5.107 3.28e-07 ***
# s_state_d:landuse_factorDeciduous       0.154110   0.077419   1.991  0.04653 *  
# s_state_d:landuse_factorMixed          -0.087178   0.032908  -2.649  0.00807 ** 
# s_state_d:landuse_factorOpen/shrub/bog -0.058494   0.038176  -1.532  0.12547    
# s_state_d:landuse_factorNew forest     -0.009961   0.029008  -0.343  0.73132   

# remove non significant ta_ parameter


TMBStruc_state.1<- glmmTMB(
  num_case_ ~ -1 +  s_sl_  + s_slope +
    s_state_d +
    landuse_factor + s_state_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_state.1$parameters$theta[1] = log(1e3)  
TMBStruc_state.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_state.1 <- glmmTMB:::fitTMB(TMBStruc_state.1)
summary(model_glmm_state.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404717.7  404871.9 -202343.8  404687.7    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 2.987e-05 5.465e-03
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                         Estimate Std. Error z value Pr(>|z|)    
# s_sl_                                   0.133068   0.006690  19.891  < 2e-16 ***
# s_slope                                -0.007465   0.009674  -0.772   0.4403    
# s_state_d                               0.368028   0.079469   4.631 3.64e-06 ***
# landuse_factorConiferous               -3.012717   7.129078  -0.423   0.6726    
# landuse_factorHuman-modified           -3.318767   7.129149  -0.466   0.6416    
# landuse_factorDeciduous                -2.708587   7.129252  -0.380   0.7040    
# landuse_factorMixed                    -2.970957   7.129078  -0.417   0.6769    
# landuse_factorOpen/shrub/bog           -2.960067   7.129113  -0.415   0.6780    
# landuse_factorNew forest               -2.649234   7.129064  -0.372   0.7102    
# s_state_d:landuse_factorHuman-modified  0.213733   0.041904   5.100 3.39e-07 ***
# s_state_d:landuse_factorDeciduous       0.154177   0.077407   1.992   0.0464 *  
# s_state_d:landuse_factorMixed          -0.087118   0.032901  -2.648   0.0081 ** 
# s_state_d:landuse_factorOpen/shrub/bog -0.058451   0.038167  -1.531   0.1257    
# s_state_d:landuse_factorNew forest     -0.009893   0.029004  -0.341   0.7330    


# remove slope parameter


TMBStruc_state.2<- glmmTMB(
  num_case_ ~ -1 +  s_sl_  +
    s_state_d +
    landuse_factor + s_state_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_state.2$parameters$theta[1] = log(1e3)  
TMBStruc_state.2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_state.2 <- glmmTMB:::fitTMB(TMBStruc_state.2)
summary(model_glmm_state.2)
# 
#       AIC       BIC    logLik  deviance  df.resid 
#  404716.3  404860.3 -202344.1  404688.3    216422 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 2.197e-05 4.687e-03
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                         Estimate Std. Error z value Pr(>|z|)    
# s_sl_                                   0.133074   0.006690  19.893  < 2e-16 ***
# s_state_d                               0.370273   0.079415   4.663 3.12e-06 ***
# landuse_factorConiferous               -3.011692   7.129085  -0.422   0.6727    
# landuse_factorHuman-modified           -3.321322   7.129155  -0.466   0.6413    
# landuse_factorDeciduous                -2.709405   7.129259  -0.380   0.7039    
# landuse_factorMixed                    -2.970686   7.129085  -0.417   0.6769    
# landuse_factorOpen/shrub/bog           -2.959355   7.129120  -0.415   0.6781    
# landuse_factorNew forest               -2.649305   7.129071  -0.372   0.7102    
# s_state_d:landuse_factorHuman-modified  0.214545   0.041891   5.121 3.03e-07 ***
# s_state_d:landuse_factorDeciduous       0.152581   0.077386   1.972   0.0486 *  
# s_state_d:landuse_factorMixed          -0.087518   0.032895  -2.661   0.0078 ** 
# s_state_d:landuse_factorOpen/shrub/bog -0.058590   0.038165  -1.535   0.1247    
# s_state_d:landuse_factorNew forest     -0.009828   0.029002  -0.339   0.7347  

#------------------------------------------------------------------season -------------------------------------

steps3$season <- steps3$season %>% relevel(ref = "Winter")


TMBStruc2.0 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_ta_ + s_slope +
    s_state_d + s_local_d + 
    landuse_factor +
    season:s_state_d + season:s_local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.0$parameters$theta[1] = log(1e3)  
TMBStruc2.0$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.0 <- glmmTMB:::fitTMB(TMBStruc2.0)
summary(model_glmm2.0)


#       AIC       BIC    logLik  deviance  df.resid 
#  404755.8  404920.4 -202361.9  404723.8    216420 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 4.677e-05 6.839e-03
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# s_sl_                         0.131187   0.006690  19.608  < 2e-16 ***
# s_ta_                         0.005018   0.007521   0.667 0.504647    
# s_slope                      -0.007712   0.009685  -0.796 0.425871    
# s_state_d                     0.490577   0.126460   3.879 0.000105 ***
# s_local_d                    -0.046331   0.036136  -1.282 0.199799    
# landuse_factorConiferous     -3.014595   7.129086  -0.423 0.672398    
# landuse_factorHuman-modified -3.327532   7.129158  -0.467 0.640679    
# landuse_factorDeciduous      -2.760620   7.129216  -0.387 0.698589    
# landuse_factorMixed          -2.970768   7.129086  -0.417 0.676890    
# landuse_factorOpen/shrub/bog -2.969465   7.129120  -0.417 0.677025    
# landuse_factorNew forest     -2.645276   7.129072  -0.371 0.710597    
# s_state_d:seasonSummer       -0.160876   0.176613  -0.911 0.362350    
# s_state_d:seasonSpring       -0.140459   0.201161  -0.698 0.485027    
# s_local_d:seasonSummer        0.222720   0.050601   4.401 1.08e-05 ***
# s_local_d:seasonSpring        0.134568   0.058009   2.320 0.020352 *  

# PLEASE CHECK WHAT NEEDS TO BE REMOVED
# remove 1 predictor

TMBStruc2.1 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_ta_ + s_slope +
    s_state_d + s_local_d + 
    landuse_factor +
    season:s_state_d + season:s_local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.1$parameters$theta[1] = log(1e3)  
TMBStruc2.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.1 <- glmmTMB:::fitTMB(TMBStruc2.1)
summary(model_glmm2.1)

#please check what to remove
# remove another predictor
TMBStruc2.2 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_ta_ + s_slope +
    s_state_d + s_local_d + 
    landuse_factor +
    season:s_state_d + season:s_local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.2$parameters$theta[1] = log(1e3)  
TMBStruc2.2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.2 <- glmmTMB:::fitTMB(TMBStruc2.2)
summary(model_glmm2.2)

# changed to winter as reference

steps3$season <- steps3$season %>% relevel(ref = "Winter")


TMBStruc2.0.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    state_d + local_d + 
    landuse_factor +
    season:state_d + season:local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.0.1$parameters$theta[1] = log(1e3)  
TMBStruc2.0.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.0.1 <- glmmTMB:::fitTMB(TMBStruc2.0.1)
summary(model_glmm2.0.1)


#       AIC       BIC    logLik  deviance  df.resid 
#  404810.6  404964.9 -202390.3  404780.6    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.472e-01    0.3836
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.053675   7.132130  -0.428   0.6685    
# log_sl_                       0.132466   0.007898  16.773  < 2e-16 ***
# cos_ta_                      -0.001384   0.007507  -0.184   0.8537    
# state_d                       0.304266   0.128304   2.371   0.0177 *  
# local_d                       0.186996   0.036415   5.135 2.82e-07 ***
# landuse_factorHuman-modified -0.347723   0.046235  -7.521 5.44e-14 ***
# landuse_factorDeciduous       0.293116   0.053588   5.470 4.50e-08 ***
# landuse_factorMixed           0.048729   0.032922   1.480   0.1388    
# landuse_factorOpen/shrub/bog  0.028992   0.038994   0.744   0.4572    
# landuse_factorNew forest      0.362549   0.027313  13.274  < 2e-16 ***
# state_d:seasonSummerSpring    0.124582   0.207790   0.600   0.5488    
# state_d:seasonSummerWinter    0.140828   0.183673   0.767   0.4432    
# local_d:seasonSummerSpring   -0.050732   0.059318  -0.855   0.3924    
# local_d:seasonSummerWinter   -0.230134   0.051796  -4.443 8.87e-06 ***


#spring as reference


#       AIC       BIC    logLik  deviance  df.resid 
#  404810.6  404964.9 -202390.3  404780.6    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.526e-01    0.3906
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.051341   7.132240  -0.428  0.66878    
# log_sl_                       0.132460   0.007898  16.772  < 2e-16 ***
# cos_ta_                      -0.001383   0.007507  -0.184  0.85383    
# state_d                       0.428794   0.163548   2.622  0.00875 ** 
# local_d                       0.136241   0.046967   2.901  0.00372 ** 
# landuse_factorHuman-modified -0.347719   0.046235  -7.521 5.45e-14 ***
# landuse_factorDeciduous       0.293082   0.053588   5.469 4.52e-08 ***
# landuse_factorMixed           0.048722   0.032922   1.480  0.13889    
# landuse_factorOpen/shrub/bog  0.028999   0.038994   0.744  0.45707    
# landuse_factorNew forest      0.362542   0.027313  13.274  < 2e-16 ***
# state_d:factor(season)Summer -0.124571   0.207791  -0.600  0.54884    
# state_d:factor(season)Winter  0.016286   0.209741   0.078  0.93811    
# local_d:factor(season)Summer  0.050751   0.059318   0.856  0.39223    
# local_d:factor(season)Winter -0.179359   0.059527  -3.013  0.00259 ** 

# winter as reference

#       AIC       BIC    logLik  deviance  df.resid 
#  404810.6  404964.9 -202390.3  404780.6    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.532e-01    0.3914
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.051145   7.132255  -0.428 0.668800    
# log_sl_                       0.132472   0.007898  16.774  < 2e-16 ***
# cos_ta_                      -0.001380   0.007507  -0.184 0.854138    
# state_d                       0.445158   0.131577   3.383 0.000716 ***
# local_d                      -0.043098   0.037036  -1.164 0.244543    
# landuse_factorHuman-modified -0.347697   0.046235  -7.520 5.47e-14 ***
# landuse_factorDeciduous       0.293065   0.053588   5.469 4.53e-08 ***
# landuse_factorMixed           0.048731   0.032922   1.480 0.138822    
# landuse_factorOpen/shrub/bog  0.029019   0.038994   0.744 0.456761    
# landuse_factorNew forest      0.362526   0.027313  13.273  < 2e-16 ***
# state_d:seasonSummer         -0.140878   0.183672  -0.767 0.443078    
# state_d:seasonSpring         -0.016337   0.209740  -0.078 0.937914    
# local_d:seasonSummer          0.230114   0.051795   4.443 8.88e-06 ***
# local_d:seasonSpring          0.179345   0.059527   3.013 0.002588 ** 


TMBStruc2.0.2 <- glmmTMB(
  case_ ~ log_sl_ +
    state_d + local_d + 
    landuse_factor +
    season:state_d + season:local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.0.2$parameters$theta[1] = log(1e3)  
TMBStruc2.0.2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.0.2 <- glmmTMB:::fitTMB(TMBStruc2.0.2)
summary(model_glmm2.0.2)

#       AIC       BIC    logLik  deviance  df.resid 
#  404828.3  404972.3 -202400.1  404800.3    216422 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.478e-01    0.3844
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.064864   7.132153  -0.430   0.6674    
# log_sl_                       0.131221   0.007889  16.632  < 2e-16 ***
# state_d                       0.542282   0.131407   4.127 3.68e-05 ***
# local_d                      -0.049561   0.037123  -1.335   0.1819    
# landuse_factorHuman-modified -0.311534   0.046076  -6.761 1.37e-11 ***
# landuse_factorDeciduous       0.252048   0.053434   4.717 2.39e-06 ***
# landuse_factorMixed           0.044486   0.032881   1.353   0.1761    
# landuse_factorOpen/shrub/bog  0.049030   0.039000   1.257   0.2087    
# landuse_factorNew forest      0.370096   0.027377  13.518  < 2e-16 ***
# state_d:seasonSummer         -0.178937   0.183779  -0.974   0.3302    
# state_d:seasonSpring         -0.167204   0.209003  -0.800   0.4237    
# local_d:seasonSummer          0.236541   0.051982   4.550 5.35e-06 ***
# local_d:seasonSpring          0.150533   0.059501   2.530   0.0114 *  


# remove predictor


TMBStruc2.0.3 <- glmmTMB(
  case_ ~ log_sl_ +
    state_d + local_d + 
    landuse_factor +
    season:local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.0.3$parameters$theta[1] = log(1e3)  
TMBStruc2.0.3$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.0.3 <- glmmTMB:::fitTMB(TMBStruc2.0.3)
summary(model_glmm2.0.3)

#       AIC       BIC    logLik  deviance  df.resid 
#  404825.4  404948.8 -202400.7  404801.4    216424 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.473e-01    0.3838
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.061337   7.132124  -0.429   0.6678    
# log_sl_                       0.131205   0.007889  16.631  < 2e-16 ***
# state_d                       0.432547   0.080110   5.399 6.69e-08 ***
# local_d                      -0.044784   0.036857  -1.215   0.2243    
# landuse_factorHuman-modified -0.312165   0.046067  -6.776 1.23e-11 ***
# landuse_factorDeciduous       0.251744   0.053435   4.711 2.46e-06 ***
# landuse_factorMixed           0.044359   0.032880   1.349   0.1773    
# landuse_factorOpen/shrub/bog  0.049195   0.039001   1.261   0.2072    
# landuse_factorNew forest      0.370020   0.027376  13.516  < 2e-16 ***
# local_d:seasonSummer          0.229611   0.051534   4.456 8.37e-06 ***
# local_d:seasonSpring          0.143065   0.058760   2.435   0.0149 *  

# ---------------------------------------------------------- time ------------------------------------------
TMBStruc3 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_ta_ + s_slope +
    s_minor_d + s_major_d + s_local_d + 
    landuse_factor +
    time_category:s_minor_d + time_category:s_major_d + time_category:s_local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc3$parameters$theta[1] = log(1e3)  
TMBStruc3$mapArg = list(theta = factor(c(NA, 1)))
model_glmm3 <- glmmTMB:::fitTMB(TMBStruc3)
summary(model_glmm3)

# ---------------------------------------------------- time of day but 2 road classes ----------


TMBStruc3.0 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_ta_ + s_slope +
    s_state_d + s_local_d + 
    landuse_factor +
    time_category:s_state_d + time_category:s_local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc3.0$parameters$theta[1] = log(1e3)  
TMBStruc3.0$mapArg = list(theta = factor(c(NA, 1)))
model_glmm3.0 <- glmmTMB:::fitTMB(TMBStruc3.0)
summary(model_glmm3.0)

#       AIC       BIC    logLik  deviance  df.resid 
#  404741.2  404905.7 -202354.6  404709.2    216420 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 4.642e-05 6.813e-03
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                  Estimate Std. Error z value Pr(>|z|)    
# s_sl_                            0.131698   0.006685  19.700  < 2e-16 ***
# s_ta_                            0.004943   0.007522   0.657   0.5111    
# s_slope                         -0.008188   0.009681  -0.846   0.3977    
# s_state_d                        0.270397   0.109603   2.467   0.0136 *  
# s_local_d                        0.173266   0.031250   5.544 2.95e-08 ***
# landuse_factorConiferous        -3.000692   7.129093  -0.421   0.6738    
# landuse_factorHuman-modified    -3.314802   7.129166  -0.465   0.6420    
# landuse_factorDeciduous         -2.752435   7.129223  -0.386   0.6994    
# landuse_factorMixed             -2.958609   7.129094  -0.415   0.6781    
# landuse_factorOpen/shrub/bog    -2.960279   7.129127  -0.415   0.6780    
# landuse_factorNew forest        -2.633297   7.129080  -0.369   0.7118    
# s_state_d:time_categoryNight     0.423492   0.166812   2.539   0.0111 *  
# s_state_d:time_categoryTwilight -0.233257   0.237849  -0.981   0.3267    
# s_local_d:time_categoryNight    -0.254200   0.048067  -5.288 1.23e-07 ***
# s_local_d:time_categoryTwilight -0.079333   0.068512  -1.158   0.2469  

#remove ta_ predictor

TMBStruc3.0.1 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + s_slope +
    s_state_d + s_local_d + 
    landuse_factor +
    time_category:s_state_d + time_category:s_local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc3.0.1$parameters$theta[1] = log(1e3)  
TMBStruc3.0.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm3.0.1 <- glmmTMB:::fitTMB(TMBStruc3.0.1)
summary(model_glmm3.0.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404739.6  404893.9 -202354.8  404709.6    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 4.274e-05 6.537e-03
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                  Estimate Std. Error z value Pr(>|z|)    
# s_sl_                            0.131766   0.006685  19.712  < 2e-16 ***
# s_slope                         -0.008105   0.009679  -0.837   0.4024    
# s_state_d                        0.269412   0.109537   2.460   0.0139 *  
# s_local_d                        0.172784   0.031226   5.533 3.14e-08 ***
# landuse_factorConiferous        -3.016721   7.129086  -0.423   0.6722    
# landuse_factorHuman-modified    -3.329918   7.129159  -0.467   0.6404    
# landuse_factorDeciduous         -2.768502   7.129216  -0.388   0.6978    
# landuse_factorMixed             -2.974642   7.129087  -0.417   0.6765    
# landuse_factorOpen/shrub/bog    -2.976090   7.129120  -0.417   0.6763    
# landuse_factorNew forest        -2.649173   7.129073  -0.372   0.7102    
# s_state_d:time_categoryNight     0.423184   0.166722   2.538   0.0111 *  
# s_state_d:time_categoryTwilight -0.232580   0.237724  -0.978   0.3279    
# s_local_d:time_categoryNight    -0.254312   0.048044  -5.293 1.20e-07 ***
# s_local_d:time_categoryTwilight -0.079232   0.068481  -1.157   0.2473  


# remove slope  predictor
TMBStruc3_3.0.2 <- glmmTMB(
  num_case_ ~ -1 + s_sl_ + 
    s_state_d + s_local_d + 
    landuse_factor +
    time_category:s_state_d + time_category:s_local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc3_3.0.2$parameters$theta[1] = log(1e3)  
TMBStruc3_3.0.2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm3_3.0.2 <- glmmTMB:::fitTMB(TMBStruc3_3.0.2)
summary(model_glmm3_3.0.2)

#       AIC       BIC    logLik  deviance  df.resid 
#  404738.3  404882.3 -202355.2  404710.3    216422 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 3.219e-05 5.674e-03
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                  Estimate Std. Error z value Pr(>|z|)    
# s_sl_                            0.131764   0.006684  19.712  < 2e-16 ***
# s_state_d                        0.271432   0.109505   2.479   0.0132 *  
# s_local_d                        0.173947   0.031193   5.576 2.45e-08 ***
# landuse_factorConiferous        -3.015549   7.129087  -0.423   0.6723    
# landuse_factorHuman-modified    -3.332529   7.129159  -0.467   0.6402    
# landuse_factorDeciduous         -2.768835   7.129217  -0.388   0.6977    
# landuse_factorMixed             -2.974357   7.129088  -0.417   0.6765    
# landuse_factorOpen/shrub/bog    -2.975509   7.129121  -0.417   0.6764    
# landuse_factorNew forest        -2.649257   7.129073  -0.372   0.7102    
# s_state_d:time_categoryNight     0.423209   0.166722   2.538   0.0111 *  
# s_state_d:time_categoryTwilight -0.232657   0.237713  -0.979   0.3277    
# s_local_d:time_categoryNight    -0.254077   0.048041  -5.289 1.23e-07 ***
# s_local_d:time_categoryTwilight -0.079091   0.068477  -1.155   0.2481 




```

# ---------------------------- OTHER MODELS -------------------------------------------------------


```{r other models}





TMBStruc_t <- glmmTMB(
  case_ ~ log(sl_) + cos(ta_) + 
    log(state_d + 0.01) + sqrt(local_d) +
    log(slope) + landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3_original,
  doFit = FALSE
)

TMBStruc_t$parameters$theta[1] = log(1e3)  
TMBStruc_t$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_t <- glmmTMB:::fitTMB(TMBStruc_t)
summary(model_glmm_t)


#       AIC       BIC    logLik  deviance  df.resid 
#  404752.0  404875.4 -202364.0  404728.0    216424 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev.
#  str_ID (Intercept) 1.000e+06 1000.000
#  id     (Intercept) 2.016e-01    0.449
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -6.449100   7.140473  -0.903    0.366    
# log(sl_)                      0.123608   0.007317  16.894  < 2e-16 ***
# cos(ta_)                      0.012554   0.011876   1.057    0.290    
# log(state_d + 0.01)           0.358423   0.043852   8.174 2.99e-16 ***
# sqrt(local_d)                 0.013242   0.002619   5.055 4.29e-07 ***
# log(slope)                   -0.008590   0.008792  -0.977    0.329    
# landuse_factorHuman-modified -0.254108   0.046587  -5.454 4.91e-08 ***
# landuse_factorDeciduous       0.245474   0.053507   4.588 4.48e-06 ***
# landuse_factorMixed           0.045045   0.032915   1.369    0.171    
# landuse_factorOpen/shrub/bog  0.043019   0.038982   1.104    0.270    
# landuse_factorNew forest      0.370055   0.027470  13.471  < 2e-16 ***

# time of day


TMBStruc_t2 <- glmmTMB(
  case_ ~ log(sl_) + cos(ta_) + 
    log(state_d + 0.01) + sqrt(local_d) +
    log(slope) + landuse_factor +
    log(state_d + 0.01):time_category + sqrt(local_d):time_category +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3_original,
  doFit = FALSE
)

TMBStruc_t2$parameters$theta[1] = log(1e3)  
TMBStruc_t2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_t2 <- glmmTMB:::fitTMB(TMBStruc_t2)
summary(model_glmm_t2)


#       AIC       BIC    logLik  deviance  df.resid 
#  404716.9  404881.5 -202342.4  404684.9    216420 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 2.053e-01    0.4531
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                            Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                               -6.503251   7.140649  -0.911    0.362    
# log(sl_)                                   0.124934   0.007324  17.058  < 2e-16 ***
# cos(ta_)                                   0.012373   0.011880   1.041    0.298    
# log(state_d + 0.01)                        0.391372   0.069054   5.668 1.45e-08 ***
# sqrt(local_d)                              0.028083   0.003889   7.222 5.13e-13 ***
# log(slope)                                -0.008828   0.008799  -1.003    0.316    
# landuse_factorHuman-modified              -0.269145   0.046760  -5.756 8.62e-09 ***
# landuse_factorDeciduous                    0.246225   0.053493   4.603 4.17e-06 ***
# landuse_factorMixed                        0.046441   0.032935   1.410    0.159    
# landuse_factorOpen/shrub/bog               0.046726   0.038996   1.198    0.231    
# landuse_factorNew forest                   0.370941   0.027476  13.500  < 2e-16 ***
# log(state_d + 0.01):time_categoryNight    -0.015985   0.094281  -0.170    0.865    
# log(state_d + 0.01):time_categoryTwilight -0.202900   0.125370  -1.618    0.106    
# sqrt(local_d):time_categoryNight          -0.033946   0.005518  -6.152 7.65e-10 ***
# sqrt(local_d):time_categoryTwilight       -0.004758   0.008268  -0.575    0.565  


TMBStruc_t3 <- glmmTMB(
  case_ ~ log(sl_) + cos(ta_) + 
    log(state_d + 0.01) + sqrt(local_d) +
    log(slope) + landuse_factor +
    log(state_d + 0.01):season + sqrt(local_d):season +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3_original,
  doFit = FALSE
)

TMBStruc_t3$parameters$theta[1] = log(1e3)  
TMBStruc_t3$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_t3 <- glmmTMB:::fitTMB(TMBStruc_t3)
summary(model_glmm_t3)

#       AIC       BIC    logLik  deviance  df.resid 
#  404728.6  404893.1 -202348.3  404696.6    216420 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 2.053e-01    0.4531
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                      -6.493282   7.140459  -0.909   0.3632    
# log(sl_)                          0.124121   0.007320  16.957  < 2e-16 ***
# cos(ta_)                          0.012355   0.011879   1.040   0.2983    
# log(state_d + 0.01)               0.459277   0.080104   5.733 9.84e-09 ***
# sqrt(local_d)                     0.025652   0.004267   6.012 1.83e-09 ***
# log(slope)                       -0.008532   0.008798  -0.970   0.3321    
# landuse_factorHuman-modified     -0.269821   0.046742  -5.773 7.81e-09 ***
# landuse_factorDeciduous           0.254336   0.053541   4.750 2.03e-06 ***
# landuse_factorMixed               0.048341   0.032930   1.468   0.1421    
# landuse_factorOpen/shrub/bog      0.053068   0.039021   1.360   0.1738    
# landuse_factorNew forest          0.372828   0.027482  13.566  < 2e-16 ***
# log(state_d + 0.01):seasonSpring -0.105386   0.114822  -0.918   0.3587    
# log(state_d + 0.01):seasonWinter -0.180944   0.101855  -1.776   0.0757 .  
# sqrt(local_d):seasonSpring       -0.006009   0.006745  -0.891   0.3731    
# sqrt(local_d):seasonWinter       -0.029136   0.005945  -4.901 9.54e-07 ***

#------------------------------------------------- making road crossing detection -----------------------

steps3$row_id <- 1:nrow(steps3)

steps_lines <- st_sf(
  geometry = mapply(
    function(x1, y1, x2, y2) {
      st_linestring(matrix(c(x1, y1, x2, y2), ncol = 2, byrow = TRUE))
    },
    steps3$x1_, steps3$y1_, steps3$x2_, steps3$y2_,
    SIMPLIFY = FALSE
  ),
  row_id = steps3$row_id,
  step_id_ = steps3$step_id_,
  case_ = steps3$case_,
  crs = 3301
) 


# data frame with crossing information
crossing_data <- data.frame(
  row_id = steps_lines$row_id,
  crosses_major = lengths(st_intersects(steps_lines, roads[roads$class >= 2, ])) > 0,
  crosses_minor = lengths(st_intersects(steps_lines, roads[roads$class == 1, ])) > 0,
  crosses_local = lengths(st_intersects(steps_lines, roads[roads$class == 0, ])) > 0
)

#crossing information back to steps3
steps3 <- merge(steps3, crossing_data, by = "row_id", all.x = TRUE)
steps3$crosses_state <- steps3$crosses_major | steps3$crosses_minor



table(steps3$crosses_major[steps3$case_ == 'FALSE'])
#  FALSE   TRUE 
# 196254    506 
table(steps3$crosses_minor[steps3$case_ == 'FALSE'])
#  FALSE   TRUE 
# 196533    227 
table(steps3$crosses_local[steps3$case_ == 'FALSE'])
#  FALSE   TRUE 
# 187404   9356 
table(steps3$crosses_major[steps3$case_ == 'TRUE'])
# FALSE  TRUE 
# 19657    19 
table(steps3$crosses_minor[steps3$case_ == 'TRUE'])
# FALSE  TRUE 
# 19645    31 
table(steps3$crosses_local[steps3$case_ == 'TRUE'])
# FALSE  TRUE 
# 18920   756 

# -------------------------------------------------------------------- crossing  -------------

# Define GLMM structure without fitting
TMBStruc22 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc22$parameters$theta[1] = log(1e3)  

TMBStruc22$mapArg = list(theta = factor(c(NA, 1)))

model_glmm22 <- glmmTMB:::fitTMB(TMBStruc22)

summary(model_glmm22)

#       AIC       BIC    logLik  deviance  df.resid 
#  364523.2  364635.2 -182250.6  364501.2    194810 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.528e-01    0.3909
# Number of obs: 194821, groups:  str_ID, 17711; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -2.889117   7.517020  -0.384   0.7007    
# log_sl_                       0.152736   0.008532  17.902  < 2e-16 ***
# cos_ta_                       0.009919   0.007932   1.251   0.2111    
# crosses_minorTRUE             0.430581   0.217417   1.980   0.0477 *  
# crosses_majorTRUE            -1.064889   0.244930  -4.348 1.38e-05 ***
# crosses_localTRUE            -0.396981   0.045602  -8.705  < 2e-16 ***
# landuse_factorHuman-modified -0.497643   0.048607 -10.238  < 2e-16 ***
# landuse_factorDeciduous       0.235597   0.058366   4.037 5.42e-05 ***
# landuse_factorMixed          -0.029234   0.036510  -0.801   0.4233    
# landuse_factorOpen/shrub/bog -0.039269   0.040255  -0.976   0.3293  


# Define GLMM structure without fitting
TMBStruc22.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_state+ crosses_local + 
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc22.1$parameters$theta[1] = log(1e3)  

TMBStruc22.1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm22.1 <- glmmTMB:::fitTMB(TMBStruc22.1)

summary(model_glmm22.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404794.5  404907.6 -202386.3  404772.5    216425 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.505e-01    0.3879
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.034393   7.132197  -0.425  0.67051    
# log_sl_                       0.146088   0.008085  18.069  < 2e-16 ***
# cos_ta_                       0.007087   0.007518   0.943  0.34586    
# crosses_stateTRUE            -0.505611   0.157549  -3.209  0.00133 ** 
# crosses_localTRUE            -0.388381   0.044507  -8.726  < 2e-16 ***
# landuse_factorHuman-modified -0.321049   0.045711  -7.023 2.16e-12 ***
# landuse_factorDeciduous       0.242579   0.053416   4.541 5.59e-06 ***
# landuse_factorMixed           0.033149   0.032871   1.008  0.31324    
# landuse_factorOpen/shrub/bog  0.046538   0.039024   1.193  0.23305    
# landuse_factorNew forest      0.360495   0.027393  13.160  < 2e-16 ***

# ---- crossing with landuse interaction -----

# Model for major roads only 
TMBStruc_major <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_major + landuse_factor + landuse_factor:crosses_major +
    (1 | str_ID) + (1 | id), 
  family = poisson, data = steps3, doFit = FALSE
)
TMBStruc_major$parameters$theta[1] = log(1e3)  
TMBStruc_major$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_major <- glmmTMB:::fitTMB(TMBStruc_major)
summary(model_glmm_major)

#       AIC       BIC    logLik  deviance  df.resid 
#  404836.1  404990.4 -202403.1  404806.1    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance Std.Dev. 
#  str_ID (Intercept) 1.00e+06 1000.0000
#  id     (Intercept) 1.55e-01    0.3937
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                  Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                     -3.121350   7.132286  -0.438  0.66165    
# log_sl_                                          0.133779   0.007911  16.911  < 2e-16 ***
# cos_ta_                                         -0.002659   0.007498  -0.355  0.72287    
# crosses_majorTRUE                               -1.210769   0.396425  -3.054  0.00226 ** 
# landuse_factorHuman-modified                    -0.374800   0.045678  -8.205 2.30e-16 ***
# landuse_factorDeciduous                          0.275554   0.053571   5.144 2.69e-07 ***
# landuse_factorMixed                              0.035282   0.032877   1.073  0.28321    
# landuse_factorOpen/shrub/bog                     0.021940   0.038952   0.563  0.57326    
# landuse_factorNew forest                         0.352404   0.027324  12.897  < 2e-16 ***
# crosses_majorTRUE:landuse_factorHuman-modified  -0.577308   0.818516  -0.705  0.48062    
# crosses_majorTRUE:landuse_factorDeciduous       -5.754605  35.374804  -0.163  0.87077    
# crosses_majorTRUE:landuse_factorMixed          -11.072074 176.679731  -0.063  0.95003    
# crosses_majorTRUE:landuse_factorOpen/shrub/bog   0.820626   0.851219   0.964  0.33502    
# crosses_majorTRUE:landuse_factorNew forest       0.840924   0.537496   1.565  0.11770   

# Model for minor roads only
TMBStruc_minor <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + landuse_factor + landuse_factor:crosses_minor +
    (1 | str_ID) + (1 | id), 
  family = poisson, data = steps3, doFit = FALSE
)
TMBStruc_minor$parameters$theta[1] = log(1e3)  
TMBStruc_minor$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_minor <- glmmTMB:::fitTMB(TMBStruc_minor)
summary(model_glmm_minor)

#       AIC       BIC    logLik  deviance  df.resid 
#  404887.3  405041.5 -202428.6  404857.3    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.584e-01    0.3979
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                  Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                     -3.134067   7.132365  -0.439    0.660    
# log_sl_                                          0.129696   0.007893  16.431  < 2e-16 ***
# cos_ta_                                          0.003916   0.007508   0.522    0.602    
# crosses_minorTRUE                                0.827793   0.792521   1.045    0.296    
# landuse_factorHuman-modified                    -0.346678   0.045641  -7.596 3.06e-14 ***
# landuse_factorDeciduous                          0.238571   0.053403   4.467 7.92e-06 ***
# landuse_factorMixed                              0.030468   0.032836   0.928    0.353    
# landuse_factorOpen/shrub/bog                     0.045672   0.038953   1.172    0.241    
# landuse_factorNew forest                         0.362230   0.027372  13.234  < 2e-16 ***
# crosses_minorTRUE:landuse_factorHuman-modified  -0.376107   0.840768  -0.447    0.655    
# crosses_minorTRUE:landuse_factorDeciduous       -6.670864  36.615272  -0.182    0.855    
# crosses_minorTRUE:landuse_factorMixed           -0.531118   0.910766  -0.583    0.560    
# crosses_minorTRUE:landuse_factorOpen/shrub/bog -11.515398 137.840339  -0.084    0.933    
# crosses_minorTRUE:landuse_factorNew forest      -0.397274   0.886014  -0.448    0.654 



# Model for local roads only
TMBStruc_local <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_local + landuse_factor + landuse_factor:crosses_local +
    (1 | str_ID) + (1 | id), 
  family = poisson, data = steps3, doFit = FALSE
)
TMBStruc_local$parameters$theta[1] = log(1e3)  
TMBStruc_local$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_local <- glmmTMB:::fitTMB(TMBStruc_local)
summary(model_glmm_local)


#       AIC       BIC    logLik  deviance  df.resid 
#  404791.3  404945.6 -202380.7  404761.3    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.526e-01    0.3907
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                 Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                    -3.033812   7.132235  -0.425  0.67057    
# log_sl_                                         0.143855   0.008063  17.840  < 2e-16 ***
# cos_ta_                                         0.006728   0.007518   0.895  0.37082    
# crosses_localTRUE                              -0.487034   0.106486  -4.574 4.79e-06 ***
# landuse_factorHuman-modified                   -0.311997   0.046971  -6.642 3.09e-11 ***
# landuse_factorDeciduous                         0.243007   0.053949   4.504 6.66e-06 ***
# landuse_factorMixed                             0.036068   0.033472   1.078  0.28122    
# landuse_factorOpen/shrub/bog                    0.045872   0.039909   1.149  0.25039    
# landuse_factorNew forest                        0.344017   0.027925  12.319  < 2e-16 ***
# crosses_localTRUE:landuse_factorHuman-modified -0.043880   0.140148  -0.313  0.75421    
# crosses_localTRUE:landuse_factorDeciduous      -0.064051   0.267828  -0.239  0.81099    
# crosses_localTRUE:landuse_factorMixed          -0.048188   0.141362  -0.341  0.73319    
# crosses_localTRUE:landuse_factorOpen/shrub/bog  0.057982   0.162816   0.356  0.72175    
# crosses_localTRUE:landuse_factorNew forest      0.397495   0.126559   3.141  0.00168 ** 

# Model for state roads only (major + minor)
TMBStruc_state <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_state + landuse_factor + landuse_factor:crosses_state +
    (1 | str_ID) + (1 | id), 
  family = poisson, data = steps3, doFit = FALSE
)
TMBStruc_state$parameters$theta[1] = log(1e3)  
TMBStruc_state$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_state <- glmmTMB:::fitTMB(TMBStruc_state)
summary(model_glmm_state)

#       AIC       BIC    logLik  deviance  df.resid 
#  404875.7  405029.9 -202422.8  404845.7    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.622e-01    0.4027
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                  Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                     -3.060150   7.132441  -0.429  0.66789    
# log_sl_                                          0.132360   0.007911  16.731  < 2e-16 ***
# cos_ta_                                          0.004402   0.007509   0.586  0.55773    
# crosses_stateTRUE                               -0.941005   0.351594  -2.676  0.00744 ** 
# landuse_factorHuman-modified                    -0.344694   0.045702  -7.542 4.62e-14 ***
# landuse_factorDeciduous                          0.239500   0.053468   4.479 7.49e-06 ***
# landuse_factorMixed                              0.029806   0.032848   0.907  0.36420    
# landuse_factorOpen/shrub/bog                     0.041836   0.038966   1.074  0.28298    
# landuse_factorNew forest                         0.358799   0.027405  13.092  < 2e-16 ***
# crosses_stateTRUE:landuse_factorHuman-modified   0.596169   0.442612   1.347  0.17800    
# crosses_stateTRUE:landuse_factorDeciduous       -9.651756 131.037503  -0.074  0.94128    
# crosses_stateTRUE:landuse_factorMixed            0.153345   0.552349   0.278  0.78130    
# crosses_stateTRUE:landuse_factorOpen/shrub/bog   0.057800   0.809374   0.071  0.94307    
# crosses_stateTRUE:landuse_factorNew forest       0.834671   0.439109   1.901  0.05732 . 

#------------------------------------------------------------------season 2: with crossing --------------------------
# Define GLMM structure without fitting
TMBStruc33 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    factor(season):crosses_minor + factor(season):crosses_major + factor(season):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc33$parameters$theta[1] = log(1e3)  

TMBStruc33$mapArg = list(theta = factor(c(NA, 1)))

model_glmm33 <- glmmTMB:::fitTMB(TMBStruc33)

summary(model_glmm33)

#       AIC       BIC    logLik  deviance  df.resid 
#  364519.3  364712.7 -182240.6  364481.3    194802 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.852e-01    0.4303
# Number of obs: 194821, groups:  str_ID, 17711; id, 8
# 
# Conditional model:
#                                          Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                             -2.805462  12.928231  -0.217 0.828206    
# log_sl_                                  0.152628   0.008531  17.890  < 2e-16 ***
# cos_ta_                                  0.010191   0.007933   1.285 0.198949    
# crosses_minorTRUE                        0.552465   0.319454   1.729 0.083737 .  
# crosses_majorTRUE                       -0.595107   0.358432  -1.660 0.096853 .  
# crosses_localTRUE                       -0.276450   0.077844  -3.551 0.000383 ***
# landuse_factorHuman-modified            -0.499699   0.048623 -10.277  < 2e-16 ***
# landuse_factorDeciduous                  0.233602   0.058356   4.003 6.25e-05 ***
# landuse_factorMixed                     -0.030514   0.036512  -0.836 0.403316    
# landuse_factorOpen/shrub/bog            -0.041978   0.040286  -1.042 0.297416    
# crosses_minorFALSE:factor(season)Summer  0.115324  17.845459   0.006 0.994844    
# crosses_minorTRUE:factor(season)Summer  -1.353534  17.863601  -0.076 0.939602    
# crosses_minorFALSE:factor(season)Winter -0.474857  19.036783  -0.025 0.980099    
# crosses_minorTRUE:factor(season)Winter  -0.203714  19.042630  -0.011 0.991465    
# crosses_majorTRUE:factor(season)Summer  -0.176694   0.543362  -0.325 0.745040    
# crosses_majorTRUE:factor(season)Winter  -1.533119   0.697401  -2.198 0.027925 *  
# crosses_localTRUE:factor(season)Summer  -0.090096   0.105826  -0.851 0.394569    
# crosses_localTRUE:factor(season)Winter  -0.298422   0.114455  -2.607 0.009125 ** 

TMBStruc33.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_state + crosses_local + 
    landuse_factor +
    factor(season):crosses_state + factor(season):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc33.1$parameters$theta[1] = log(1e3)  

TMBStruc33.1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm33.1 <- glmmTMB:::fitTMB(TMBStruc33.1)

summary(model_glmm33.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404801.3  404976.1 -202383.6  404767.3    216419 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.782e-01    0.4221
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                          Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                             -2.798896  11.607314  -0.241   0.8095    
# log_sl_                                  0.145951   0.008085  18.052  < 2e-16 ***
# cos_ta_                                  0.007143   0.007518   0.950   0.3421    
# crosses_stateTRUE                       -0.461608   0.231307  -1.996   0.0460 *  
# crosses_localTRUE                       -0.481880   0.072439  -6.652 2.89e-11 ***
# landuse_factorHuman-modified            -0.320839   0.045728  -7.016 2.28e-12 ***
# landuse_factorDeciduous                  0.242201   0.053398   4.536 5.74e-06 ***
# landuse_factorMixed                      0.033526   0.032870   1.020   0.3078    
# landuse_factorOpen/shrub/bog             0.046380   0.039025   1.188   0.2347    
# landuse_factorNew forest                 0.360306   0.027393  13.153  < 2e-16 ***
# crosses_stateFALSE:factor(season)Summer -0.333922  16.439546  -0.020   0.9838    
# crosses_stateTRUE:factor(season)Summer  -0.773003  16.444946  -0.047   0.9625    
# crosses_stateFALSE:factor(season)Spring -0.418961  18.434138  -0.023   0.9819    
# crosses_stateTRUE:factor(season)Spring  -0.235523  18.437575  -0.013   0.9898    
# crosses_localTRUE:factor(season)Summer   0.125895   0.101196   1.244   0.2135    
# crosses_localTRUE:factor(season)Spring   0.188938   0.112711   1.676   0.0937 . 


TMBStruc33.2 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_state + crosses_local + 
    landuse_factor +
    factor(season):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc33.2$parameters$theta[1] = log(1e3)  

TMBStruc33.2$mapArg = list(theta = factor(c(NA, 1)))

model_glmm33.2 <- glmmTMB:::fitTMB(TMBStruc33.2)

summary(model_glmm33.2)

#       AIC       BIC    logLik  deviance  df.resid 
#  404799.4  404953.6 -202384.7  404769.4    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.793e-01    0.4234
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                          Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                             -2.706548  11.607278  -0.233  0.81562    
# log_sl_                                  0.145976   0.008085  18.055  < 2e-16 ***
# cos_ta_                                  0.007176   0.007518   0.954  0.33985    
# crosses_stateTRUE                       -0.507398   0.157490  -3.222  0.00127 ** 
# crosses_localTRUE                       -0.481597   0.072430  -6.649 2.95e-11 ***
# landuse_factorHuman-modified            -0.320364   0.045720  -7.007 2.43e-12 ***
# landuse_factorDeciduous                  0.242304   0.053407   4.537 5.71e-06 ***
# landuse_factorMixed                      0.033548   0.032869   1.021  0.30742    
# landuse_factorOpen/shrub/bog             0.046240   0.039024   1.185  0.23605    
# landuse_factorNew forest                 0.360364   0.027391  13.156  < 2e-16 ***
# crosses_localFALSE:factor(season)Summer -0.563057  16.439494  -0.034  0.97268    
# crosses_localTRUE:factor(season)Summer  -0.440928  16.439781  -0.027  0.97860    
# crosses_localFALSE:factor(season)Spring -0.425244  18.434145  -0.023  0.98160    
# crosses_localTRUE:factor(season)Spring  -0.233712  18.434462  -0.013  0.98988    

# ---------------------------------------------------------- time 2: with crossings -----------------------
TMBStruc44 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    factor(time_category):crosses_minor + factor(time_category):crosses_major + factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc44$parameters$theta[1] = log(1e3)  

TMBStruc44$mapArg = list(theta = factor(c(NA, 1)))

model_glmm44 <- glmmTMB:::fitTMB(TMBStruc44)

summary(model_glmm44)

#       AIC       BIC    logLik  deviance  df.resid 
#  364525.7  364719.1 -182243.9  364487.7    194802 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance Std.Dev.
#  str_ID (Intercept) 1.00e+06 1000.000
#  id     (Intercept) 1.73e-01    0.416
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.493584  10.776294  -0.231   0.8170    
# log_sl_                                           0.152652   0.008533  17.890  < 2e-16 ***
# cos_ta_                                           0.009900   0.007932   1.248   0.2120    
# crosses_minorTRUE                                -0.052670   0.419994  -0.125   0.9002    
# crosses_majorTRUE                                -1.841373   0.589824  -3.122   0.0018 ** 
# crosses_localTRUE                                -0.408808   0.074578  -5.482 4.22e-08 ***
# landuse_factorHuman-modified                     -0.498646   0.048632 -10.254  < 2e-16 ***
# landuse_factorDeciduous                           0.234875   0.058379   4.023 5.74e-05 ***
# landuse_factorMixed                              -0.029332   0.036517  -0.803   0.4218    
# landuse_factorOpen/shrub/bog                     -0.038921   0.040264  -0.967   0.3337    
# crosses_minorFALSE:factor(time_category)Night    -0.739037  16.215502  -0.046   0.9636    
# crosses_minorTRUE:factor(time_category)Night     -0.132759  16.223472  -0.008   0.9935    
# crosses_minorFALSE:factor(time_category)Twilight -0.732099  23.523036  -0.031   0.9752    
# crosses_minorTRUE:factor(time_category)Twilight   0.465979  23.535007   0.020   0.9842    
# crosses_majorTRUE:factor(time_category)Night      0.923753   0.668422   1.382   0.1670    
# crosses_majorTRUE:factor(time_category)Twilight   1.474727   0.814244   1.811   0.0701 .  
# crosses_localTRUE:factor(time_category)Night     -0.050600   0.097499  -0.519   0.6038    
# crosses_localTRUE:factor(time_category)Twilight   0.296533   0.141770   2.092   0.0365 *  



TMBStruc44.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    factor(time_category):crosses_major + factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc44.1$parameters$theta[1] = log(1e3)  

TMBStruc44.1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm44.1 <- glmmTMB:::fitTMB(TMBStruc44.1)

summary(model_glmm44.1)


#       AIC       BIC    logLik  deviance  df.resid 
#  404797.2  404982.3 -202380.6  404761.2    216418 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.768e-01    0.4205
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.581427  10.143135  -0.254  0.79911    
# log_sl_                                           0.145857   0.008074  18.064  < 2e-16 ***
# cos_ta_                                           0.006827   0.007516   0.908  0.36377    
# crosses_minorTRUE                                 0.454830   0.213478   2.131  0.03312 *  
# crosses_majorTRUE                                -1.811236   0.589111  -3.075  0.00211 ** 
# crosses_localTRUE                                -0.366286   0.073226  -5.002 5.67e-07 ***
# landuse_factorHuman-modified                     -0.323569   0.045819  -7.062 1.64e-12 ***
# landuse_factorDeciduous                           0.280108   0.053764   5.210 1.89e-07 ***
# landuse_factorMixed                               0.055612   0.032873   1.692  0.09070 .  
# landuse_factorOpen/shrub/bog                      0.051683   0.039172   1.319  0.18705    
# landuse_factorNew forest                          0.357185   0.027352  13.059  < 2e-16 ***
# crosses_majorFALSE:factor(time_category)Night    -0.860312  15.372811  -0.056  0.95537    
# crosses_majorTRUE:factor(time_category)Night     -0.017470  15.387240  -0.001  0.99909    
# crosses_majorFALSE:factor(time_category)Twilight -0.885312  22.568467  -0.039  0.96871    
# crosses_majorTRUE:factor(time_category)Twilight   0.629273  22.582900   0.028  0.97777    
# crosses_localTRUE:factor(time_category)Night     -0.046948   0.095248  -0.493  0.62208    
# crosses_localTRUE:factor(time_category)Twilight   0.348967   0.139523   2.501  0.01238 *  



TMBStruc44.2 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc44.2$parameters$theta[1] = log(1e3)  

TMBStruc44.2$mapArg = list(theta = factor(c(NA, 1)))

model_glmm44.2 <- glmmTMB:::fitTMB(TMBStruc44.2)

summary(model_glmm44.2)


#       AIC       BIC    logLik  deviance  df.resid 
#  404796.9  404961.5 -202382.5  404764.9    216420 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev.
#  str_ID (Intercept) 1.000e+06 1000.000
#  id     (Intercept) 1.772e-01    0.421
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.794748  10.143083  -0.276   0.7829    
# log_sl_                                           0.145873   0.008074  18.066  < 2e-16 ***
# cos_ta_                                           0.006888   0.007516   0.916   0.3594    
# crosses_minorTRUE                                 0.456420   0.213455   2.138   0.0325 *  
# crosses_majorTRUE                                -1.075378   0.243580  -4.415 1.01e-05 ***
# crosses_localTRUE                                -0.370653   0.073157  -5.067 4.05e-07 ***
# landuse_factorHuman-modified                     -0.323886   0.045812  -7.070 1.55e-12 ***
# landuse_factorDeciduous                           0.280445   0.053763   5.216 1.82e-07 ***
# landuse_factorMixed                               0.055532   0.032873   1.689   0.0912 .  
# landuse_factorOpen/shrub/bog                      0.051238   0.039171   1.308   0.1909    
# landuse_factorNew forest                          0.357247   0.027353  13.061  < 2e-16 ***
# crosses_localFALSE:factor(time_category)Night    -0.502129  15.372757  -0.033   0.9739    
# crosses_localTRUE:factor(time_category)Night     -0.544434  15.373030  -0.035   0.9717    
# crosses_localFALSE:factor(time_category)Twilight -0.344569  22.568425  -0.015   0.9878    
# crosses_localTRUE:factor(time_category)Twilight   0.013748  22.568822   0.001   0.9995 

# -------------------------------------------------------------- crosses time with 2 road -------------------------

TMBStruc55 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_state+ crosses_local + 
    landuse_factor +
    factor(time_category):crosses_state + factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc55$parameters$theta[1] = log(1e3)  

TMBStruc55$mapArg = list(theta = factor(c(NA, 1)))

model_glmm55 <- glmmTMB:::fitTMB(TMBStruc55)

summary(model_glmm55)


#       AIC       BIC    logLik  deviance  df.resid 
#  404814.5  404989.3 -202390.2  404780.5    216419 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance Std.Dev. 
#  str_ID (Intercept) 1.00e+06 1000.0000
#  id     (Intercept) 1.74e-01    0.4171
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.617208  10.143089  -0.258  0.79638    
# log_sl_                                           0.146005   0.008075  18.082  < 2e-16 ***
# cos_ta_                                           0.006794   0.007516   0.904  0.36600    
# crosses_stateTRUE                                -0.983236   0.331830  -2.963  0.00305 ** 
# crosses_localTRUE                                -0.367865   0.073207  -5.025 5.04e-07 ***
# landuse_factorHuman-modified                     -0.319961   0.045802  -6.986 2.83e-12 ***
# landuse_factorDeciduous                           0.277893   0.053718   5.173 2.30e-07 ***
# landuse_factorMixed                               0.056143   0.032869   1.708  0.08762 .  
# landuse_factorOpen/shrub/bog                      0.053000   0.039172   1.353  0.17605    
# landuse_factorNew forest                          0.358126   0.027347  13.096  < 2e-16 ***
# crosses_stateFALSE:factor(time_category)Night    -0.788127  15.372811  -0.051  0.95911    
# crosses_stateTRUE:factor(time_category)Night     -0.112663  15.377747  -0.007  0.99415    
# crosses_stateFALSE:factor(time_category)Twilight -0.784587  22.568458  -0.035  0.97227    
# crosses_stateTRUE:factor(time_category)Twilight   0.517331  22.574208   0.023  0.98172    
# crosses_localTRUE:factor(time_category)Night     -0.046512   0.095223  -0.488  0.62523    
# crosses_localTRUE:factor(time_category)Twilight   0.344776   0.139541   2.471  0.01348 *  

# remove 1 non-significant

TMBStruc55.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_state+ crosses_local + 
    landuse_factor +
    factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc55.1$parameters$theta[1] = log(1e3)  

TMBStruc55.1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm55.1 <- glmmTMB:::fitTMB(TMBStruc55.1)

summary(model_glmm55.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404796.1  404950.4 -202383.0  404766.1    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.733e-01    0.4163
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.784755  10.142974  -0.275   0.7837    
# log_sl_                                           0.146043   0.008086  18.061  < 2e-16 ***
# cos_ta_                                           0.007193   0.007519   0.957   0.3387    
# crosses_stateTRUE                                -0.506580   0.157540  -3.216   0.0013 ** 
# crosses_localTRUE                                -0.428225   0.073241  -5.847 5.01e-09 ***
# landuse_factorHuman-modified                     -0.321348   0.045714  -7.030 2.07e-12 ***
# landuse_factorDeciduous                           0.243212   0.053420   4.553 5.29e-06 ***
# landuse_factorMixed                               0.033346   0.032872   1.014   0.3104    
# landuse_factorOpen/shrub/bog                      0.046441   0.039028   1.190   0.2341    
# landuse_factorNew forest                          0.360644   0.027394  13.165  < 2e-16 ***
# crosses_localFALSE:factor(time_category)Night    -0.515498  15.372696  -0.034   0.9732    
# crosses_localTRUE:factor(time_category)Night     -0.519416  15.372969  -0.034   0.9730    
# crosses_localFALSE:factor(time_category)Twilight -0.328817  22.568371  -0.015   0.9884    
# crosses_localTRUE:factor(time_category)Twilight  -0.003266  22.568761   0.000   0.9999   






```




```{r step length ~ distance to road}

# Calculate distance to nearest road for each step
steps_with_dist <- steps3_original

# Create distance bands
steps_with_dist$dist_band <- cut(steps_with_dist$state_d, 
                                breaks = c(-Inf, 50, 250, 500, 1000, 1500, 2000, Inf),
                                labels = c("0-50m", "50-250m", "250-500m", "500-1000m", "1000-1500m", "1500-2000m", ">2000m"))


# Only use used steps (case_ == TRUE)
used_steps <- steps_with_dist[steps_with_dist$case_ == TRUE,]

# Calculate mean step length by distance band
sl_by_dist <- aggregate(sl_ ~ dist_band, data = used_steps, FUN = mean)

# Visualize
ggplot(used_steps, aes(x = dist_band, y = log(sl_))) +
  geom_boxplot() +
  labs(x = "Distance to road, m", y = "Log step length, m",
       title = "Movement speed vs distance to road")

# Statistical test
model_sl <- lm(sl_ ~ dist_band, data = used_steps)
anova(model_sl)


# Convert turning angles to absolute deviation from straight-line movement
used_steps$turn_abs <- abs(used_steps$ta_)

used_steps$turn_abs_deg <- used_steps$turn_abs * (180/pi)

# Calculate mean turning angle by distance band
ta_by_dist <- aggregate(turn_abs_deg ~ dist_band, data = used_steps, FUN = mean)

# Visualize
ggplot(used_steps, aes(x = dist_band, y = turn_abs_deg)) +
  geom_boxplot() +
  labs(x = "Distance to road, m", y = "Absolute turning angle, degrees",
       title = "Movement direction persistance vs distance to road")

# Statistical test
model_ta <- lm(turn_abs ~ dist_band, data = used_steps)
anova(model_ta)

ggplot(used_steps, aes(x = ta_ * (180/pi), fill = dist_band)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~ dist_band) +
  labs(x = "Turning angle, degrees", y = "Density",
       title = "Distribution of turning Angles by distance from state road")



ggplot(used_steps, aes(x = sl_, fill = dist_band)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~ dist_band) +
  labs(x = "Log step length, m", y = "Density",
       title = "Distribution of step length by distance from state road")



ggplot(used_steps, aes(x = log(sl_))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "Step length, m", y = "Density",
       title = "Distribution of step length")



ggplot(steps3, aes(x = slope)) +
  geom_histogram(alpha = 0.5) +
  labs(x = "Slope, degrees", y = "Density")

```




```{r other other models}


# ----------------------------------------- basic with quadratic terms -------------------------------

steps3$state_d_sq <- steps3$state_d^2
steps3$local_d_sq <- steps3$local_d^2

TMBStruc1.2 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    state_d + state_d_sq +
    local_d + local_d_sq +
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc1.2$parameters$theta[1] = log(1e3)  
TMBStruc1.2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm1.2 <- glmmTMB:::fitTMB(TMBStruc1.2)
summary(model_glmm1.2)


#       AIC       BIC    logLik  deviance  df.resid 
#  404816.1  404949.8 -202395.0  404790.1    216423 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.464e-01    0.3826
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -2.915826   7.132236  -0.409   0.6827    
# log_sl_                       0.133659   0.007890  16.940  < 2e-16 ***
# cos_ta_                       0.007065   0.007520   0.940   0.3475    
# state_d                       0.459203   0.080473   5.706 1.15e-08 ***
# state_d_sq                   -0.096926   0.041649  -2.327   0.0200 *  
# local_d                       0.104419   0.023359   4.470 7.81e-06 ***
# local_d_sq                   -0.063529   0.012122  -5.241 1.60e-07 ***
# landuse_factorHuman-modified -0.265646   0.046553  -5.706 1.15e-08 ***
# landuse_factorDeciduous       0.286945   0.053815   5.332 9.71e-08 ***
# landuse_factorMixed           0.064955   0.032945   1.972   0.0487 *  
# landuse_factorOpen/shrub/bog  0.054153   0.039163   1.383   0.1667    
# landuse_factorNew forest      0.367683   0.027365  13.436  < 2e-16 ***

# ---------------------------------------------------- basic quadratic -1 ------------------------------

TMBStruc1.2.1 <- glmmTMB(
  case_ ~ log_sl_ +
    state_d + state_d_sq +
    local_d + local_d_sq +
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc1.2.1$parameters$theta[1] = log(1e3)  
TMBStruc1.2.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm1.2.1 <- glmmTMB:::fitTMB(TMBStruc1.2.1)
summary(model_glmm1.2.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404815.0  404938.4 -202395.5  404791.0    216424 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.459e-01    0.3819
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                              Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -2.91575    7.13222  -0.409   0.6827    
# log_sl_                       0.13378    0.00789  16.956  < 2e-16 ***
# state_d                       0.45764    0.08040   5.692 1.25e-08 ***
# state_d_sq                   -0.09655    0.04161  -2.320   0.0203 *  
# local_d                       0.10353    0.02332   4.439 9.05e-06 ***
# local_d_sq                   -0.06323    0.01211  -5.221 1.78e-07 ***
# landuse_factorHuman-modified -0.26431    0.04652  -5.682 1.33e-08 ***
# landuse_factorDeciduous       0.28707    0.05380   5.336 9.52e-08 ***
# landuse_factorMixed           0.06510    0.03294   1.977   0.0481 *  
# landuse_factorOpen/shrub/bog  0.05453    0.03915   1.393   0.1637    
# landuse_factorNew forest      0.36780    0.02736  13.443  < 2e-16 ***

# ----------------------------------------- time of day but in two categories ----------------------


steps3.1 <- steps3 %>% 
  mutate(
    time_category3.1 = 
      case_when(
        time_category == "Night" | time_category == "Twilight" ~ "Dark", 
        TRUE ~ "Day"
    )
  )


steps3.1$time_category3.1 <- factor(steps3.1$time_category3.1) %>% relevel(ref = "Day")



TMBStruc3.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    minor_d + major_d + local_d + 
    landuse_factor +
    time_category3.1:minor_d + time_category3.1:major_d + time_category3.1:local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3.1,
  doFit = FALSE
)

TMBStruc3.1$parameters$theta[1] = log(1e3)  

TMBStruc3.1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm3.1 <- glmmTMB:::fitTMB(TMBStruc3.1)

summary(model_glmm3.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404839.1  404993.4 -202404.5  404809.1    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev.
#  str_ID (Intercept) 1.000e+06 1000.000
#  id     (Intercept) 1.537e-01    0.392
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.066524   7.132260  -0.430   0.6672    
# log_sl_                       0.133145   0.007889  16.878  < 2e-16 ***
# cos_ta_                       0.005872   0.007516   0.781   0.4347    
# minor_d                       0.267968   0.130261   2.057   0.0397 *  
# major_d                      -0.124804   0.137594  -0.907   0.3644    
# local_d                       0.203761   0.031878   6.392 1.64e-10 ***
# landuse_factorHuman-modified -0.309251   0.046222  -6.691 2.22e-11 ***
# landuse_factorDeciduous       0.281079   0.053741   5.230 1.69e-07 ***
# landuse_factorMixed           0.060394   0.032900   1.836   0.0664 .  
# landuse_factorOpen/shrub/bog  0.049524   0.039173   1.264   0.2061    
# landuse_factorNew forest      0.362787   0.027344  13.267  < 2e-16 ***
# minor_d:time_category3.1Dark  0.110346   0.182739   0.604   0.5459    
# major_d:time_category3.1Dark  0.442162   0.193096   2.290   0.0220 *  
# local_d:time_category3.1Dark -0.208665   0.045187  -4.618 3.88e-06 ***



```


# ----------------------------------------------- VISUALISATIONS ------------------------------------


```{r inspect variables}

# --- correlations ----

numeric_predictors <- steps3 %>% select(-"x1_", -"x2_", -"y1_", -"y2_", "burst_", "step_id_")

correlation_matrix <- cor(numeric_predictors, use = "complete.obs")

print(correlation_matrix)

corrplot(correlation_matrix, method = "color", type = "upper", 
         order = "hclust", tl.col = "black", tl.srt = 45,
         diag = FALSE) 



library(polycor)


steps3$crosses_major <- as.factor(steps3$crosses_major)
steps3$crosses_minor <- as.factor(steps3$crosses_minor)
steps3$crosses_local <- as.factor(steps3$crosses_local)
steps3$time_category <- as.factor(steps3$time_category)
steps3$season <- as.factor(steps3$season)

vars_of_interest <- steps3[, c("landuse_factor", "major_d", "minor_d", "local_d", 
                               "time_category", "season", 
                               "crosses_major", "crosses_minor", "crosses_local")]


het_cor <- hetcor(vars_of_interest)
het_cor$correlations
corrplot(het_cor$correlations, method = "color", 
         type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)



# ---- distributions? ---------


ggplot(used_steps, aes(x = log(sl_))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "Step length, m", y = "Density",
       title = "Distribution of step length")



ggplot(steps3_original, aes(x = slope)) +
  geom_histogram(alpha = 0.5) +
  labs(x = "Slope, degrees", y = "Count")

ggplot(steps3_original, aes(x = scale(sl_))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "scaled Step length, m", y = "Count")

ggplot(steps3_original, aes(x = scale(state_d))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "scaled Distance to state roads, m", y = "Count")

ggplot(steps3_original, aes(x = scale(local_d))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "scaled Distance to local roads, m", y = "Count")

ggplot(steps3_original, aes(x = ta_)) +
  geom_histogram(alpha = 0.5) +
  labs(x = "Turning angle, radians", y = "Count")

# transformations -> what to make?

ggplot(steps3_original, aes(x = log(slope))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "Slope, degrees", y = "Count")

ggplot(steps3_original, aes(x = log(sl_))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "log step length, m", y = "Count")

ggplot(steps3_original, aes(x = log(state_d + 0.01))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "Log distance to state roads, m + 0.01", y = "Count")

ggplot(steps3_original, aes(x = sqrt(local_d))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "sqrt distance to local roads, m", y = "Count")

ggplot(steps3_original, aes(x = cos(ta_))) +
  geom_histogram(alpha = 0.5) +
  labs(x = "cos (turning angle in radians)", y = "Count")

# ---------------- crossings as not significant -----------------------
used_steps <- steps3[steps3$case_ == TRUE,]

crossing_counts_state <- table(
  Time = used_steps$time_category[used_steps$crosses_state == TRUE],
  Season = used_steps$season[used_steps$crosses_state == TRUE]
)
#           Season
# Time       Winter Summer Spring
#   Day           3      1      6
#   Night        16      7      7
#   Twilight      5      1      3

crossing_counts_local <- table(
  Time = used_steps$time_category[used_steps$crosses_local == TRUE],
  Season = used_steps$season[used_steps$crosses_local == TRUE]
)
#           Season
# Time       Winter Summer Spring
#   Day          44    136     81
#   Night       205     98     82
#   Twilight     28     55     27   


# > sum(crossing_counts_local$Freq[crossing_counts_local$Time == "Day"])
# [1] 261


```




```{r mean distances descriptive}


# ----------------- mean distances to roads per category --------------------


ggplot(steps3_original %>% filter(case_ == TRUE), 
       aes(x = time_category, y = local_d)) +
  geom_boxplot() +
  labs(title = "Actual distances to local roads by time of day",
       y = "Distance (m)")


ggplot(steps3_original %>% filter(case_ == TRUE), 
       aes(x = time_category, y = state_d)) +
  geom_boxplot() +
  labs(title = "Actual distances to state roads by time of day",
       y = "Distance (m)")

# Alternative approach using data.frame subsets
day_summary <- with(subset(steps3_original, case_ == TRUE & time_category == "Day"), 
                  c(local_mean = mean(local_d, na.rm = TRUE),
                    state_mean = mean(state_d, na.rm = TRUE),
                    n = length(major_d)))

night_summary <- with(subset(steps3_original, case_ == TRUE & time_category == "Night"), 
                     c(local_mean = mean(local_d, na.rm = TRUE),
                       state_mean = mean(state_d, na.rm = TRUE),
                       n = length(major_d)))

twilight_summary <- with(subset(steps3_original, case_ == TRUE & time_category == "Twilight"), 
                        c(local_mean = mean(local_d, na.rm = TRUE),
                          state_mean = mean(state_d, na.rm = TRUE),
                          n = length(major_d)))

# Combine results
daytime_summary <- rbind(Day = day_summary, Night = night_summary, Twilight = twilight_summary)


# Alternative approach using data.frame subsets
winter_summary <- with(subset(steps3_original, case_ == TRUE & season == "Winter"), 
                  c(local_mean = mean(local_d, na.rm = TRUE),
                    state_mean = mean(state_d, na.rm = TRUE),
                    n = length(major_d)))

spring_summary <- with(subset(steps3_original, case_ == TRUE & season == "Spring"), 
                     c(local_mean = mean(local_d, na.rm = TRUE),
                       state_mean = mean(state_d, na.rm = TRUE),
                       n = length(major_d)))

summer_summary <- with(subset(steps3_original, case_ == TRUE & season == "Summer"), 
                        c(local_mean = mean(local_d, na.rm = TRUE),
                          state_mean = mean(state_d, na.rm = TRUE),
                          n = length(major_d)))

# Combine results
season_summary <- rbind(Winter = winter_summary, Spring = spring_summary, Summer = summer_summary)


# adding standard error and plotting

# We need to calculate standard errors from your original data
# For each time category (Day, Night, Twilight)
time_data <- list()

# Let's calculate means and standard errors for each time category
for (time in c("Day", "Night", "Twilight")) {
  # Subset data
  subset_data <- steps3_original[steps3_original$case_ == TRUE & 
                                steps3_original$time_category == time, ]
  
  # Calculate local road statistics
  local_mean <- mean(subset_data$local_d, na.rm = TRUE)
  local_sd <- sd(subset_data$local_d, na.rm = TRUE)
  local_n <- sum(!is.na(subset_data$local_d))
  local_se <- local_sd / sqrt(local_n)
  
  # Calculate state road statistics
  state_mean <- mean(subset_data$state_d, na.rm = TRUE)
  state_sd <- sd(subset_data$state_d, na.rm = TRUE)
  state_n <- sum(!is.na(subset_data$state_d))
  state_se <- state_sd / sqrt(state_n)
  
  time_data[[time]] <- data.frame(
    time_category = time,
    local_mean = local_mean,
    local_se = local_se,
    state_mean = state_mean, 
    state_se = state_se,
    n = local_n
  )
}

# Combine results
time_df <- do.call(rbind, time_data)

# Reshape for plotting
time_long <- reshape(time_df,
                   direction = "long",
                   varying = list(c("local_mean", "state_mean"), c("local_se", "state_se")),
                   v.names = c("mean", "se"),
                   timevar = "road_type",
                   times = c("Local roads", "State roads"))

# Plot with error bars
ggplot(time_long, aes(x = time_category, y = mean, 
                    group = road_type, color = road_type)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
               width = 0.2, position = position_dodge(0.1)) +
  scale_y_continuous(name = "Distance (m)", limits = c(0, 2500)) +
  scale_color_manual(values = c("Local roads" = "#1b9e77", "State roads" = "#7570b3"),
                    name = "Road type") +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title.x = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(size = 12)
  ) +
  labs(title = "Average distance to road types by time of day")

# Similarly for season plot
season_data <- list()

for (seas in c("Winter", "Spring", "Summer")) {
  # Subset data
  subset_data <- steps3_original[steps3_original$case_ == TRUE & 
                                steps3_original$season == seas, ]
  
  # Calculate local road statistics
  local_mean <- mean(subset_data$local_d, na.rm = TRUE)
  local_sd <- sd(subset_data$local_d, na.rm = TRUE)
  local_n <- sum(!is.na(subset_data$local_d))
  local_se <- local_sd / sqrt(local_n)
  
  # Calculate state road statistics
  state_mean <- mean(subset_data$state_d, na.rm = TRUE)
  state_sd <- sd(subset_data$state_d, na.rm = TRUE)
  state_n <- sum(!is.na(subset_data$state_d))
  state_se <- state_sd / sqrt(state_n)
  
  season_data[[seas]] <- data.frame(
    season = seas,
    local_mean = local_mean,
    local_se = local_se,
    state_mean = state_mean, 
    state_se = state_se,
    n = local_n
  )
}

# Combine results
season_df <- do.call(rbind, season_data)

# Reshape for plotting
season_long <- reshape(season_df,
                     direction = "long",
                     varying = list(c("local_mean", "state_mean"), c("local_se", "state_se")),
                     v.names = c("mean", "se"),
                     timevar = "road_type",
                     times = c("Local roads", "State roads"))

# Plot with error bars
ggplot(season_long, aes(x = season, y = mean, 
                       group = road_type, color = road_type)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
               width = 0.2, position = position_dodge(0.1)) +
  scale_y_continuous(name = "Distance (m)", limits = c(0, 2500)) +
  scale_color_manual(values = c("Local roads" = "#1b9e77", "State roads" = "#7570b3"),
                    name = "Road type") +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title.x = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(size = 12)
  ) +
  labs(title = "Average distance to road types by season")

# joined 
time_long$category_type <- "Time of day"
season_long$category_type <- "Season"

# rename to be consistent
names(time_long)[names(time_long) == "time_category"] <- "category"
names(season_long)[names(season_long) == "season"] <- "category"

#combine
all_data <- rbind(time_long, season_long)

#single plot for tidy output
ggplot(all_data, aes(x = category, y = mean, 
                    group = road_type, color = road_type)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
               width = 0.2, position = position_dodge(0.1)) +
  facet_wrap(~ category_type, scales = "free_x") +
  scale_y_continuous(name = "Distance, m", limits = c(0, 2500)) +
  scale_color_manual(values = c("#ba936b", "#E6550D"),
    labels = c("Local road", "State road")) +
  labs(title = "Average distance to road types",
       color = "") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.title.x = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(size = 12, family = "Times"),
    plot.title=element_text( hjust=0.5, vjust=0.5),
    strip.text = element_text(size = 12, face = "bold")
  )



```






```{r log ratio plot }



# prepare data with used/available points and distance bands
points_data <- steps3_original %>%
  dplyr::select(time_category, state_d, case_) %>%
  mutate(point_type = ifelse(case_ == TRUE, "Used", "Available"))

# create distance bands from roads
points_data$dist_band <- cut(points_data$state_d, 
                             breaks = c(-Inf, 100, 300, 500, 1000, 1500, Inf),
                             labels = c("<100m", "100-300m", "300-500m", "500-1000m", "1000-1500m", ">1500m"))


# count observations in each group and calculate percentages
count_df <- as.data.frame(table(
  points_data$time_category, 
  points_data$point_type, 
  points_data$dist_band
))
names(count_df) <- c("time_category", "point_type", "dist_band", "count")


# add sample sizes to data for text annotation
used_counts <- subset(count_df, point_type == "Used")
names(used_counts)[4] <- "sample_size"

# calculate proportions and reshape
props_df <- count_df %>%
  group_by(time_category, point_type) %>%
  mutate(prop = count/sum(count)) %>%
  dplyr::select(-count) %>%
  pivot_wider(names_from = point_type, values_from = prop)

# calculate selection ratio and simple approximate CIs
ratio_df <- props_df %>%
  mutate(
    ratio = Used / Available,
    selection_strength = log(ratio),
    
    #  approximate confidence intervals using standard error of log ratio
    # as in the delta method for variance of log(p1/p2)
    n_used = sum(used_counts$sample_size[used_counts$time_category == time_category]),
    n_avail = n_used * 10,  # assuming 10 available points per used point
    
    se_used = sqrt(Used * (1-Used) / n_used),
    se_avail = sqrt(Available * (1-Available) / n_avail),
    
    # standard error of log ratio
    se_logratio = sqrt((se_used/Used)^2 + (se_avail/Available)^2),
    
    # 95% confidence intervals
    ci_lower = selection_strength - 1.96 * se_logratio,
    ci_upper = selection_strength + 1.96 * se_logratio
  )

# merge with sample sizes
ratio_df <- merge(ratio_df, 
                 used_counts[, c("time_category", "dist_band", "sample_size")],
                 by = c("time_category", "dist_band"))

# windowsFonts(Times=windowsFont("TT Times New Roman"))

# create the plot
ggplot(ratio_df, aes(x = dist_band, y = selection_strength, fill = time_category)) +
  geom_col(position = position_dodge(width = 0.9), alpha = 0.7) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), 
                position = position_dodge(width = 0.9),
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_manual(
    values = c("#FFC145", "#2B3A67", "#B8B8D1"),
    labels = c("Day", "Night", "Twilight")
  ) +
  labs(title = "Road distance selection strength by time of day",
       x = "Distance from state roads", 
       y = "Log ratio (used:available)",
       fill = "Time category") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title=element_text( hjust=0.5, vjust=0.5),
        text = element_text(family = "Times")) +
  ylim(-1.2, 0.5)


# --------- log odds of crossings -----------



# 1. Create a function to calculate crossing ratios with confidence intervals
calculate_crossing_ratio <- function(data, road_type = "state") {
  # Determine which crossing variable to use
  crossing_var <- paste0("crosses_", road_type)
  
  # Count observed crossings (actual moose steps)
  observed <- data[data$case_ == TRUE, ]
  total_observed <- nrow(observed)
  observed_crossings <- sum(observed[[crossing_var]])
  observed_prop <- observed_crossings / total_observed
  
  # Count expected crossings (random steps)
  expected <- data[data$case_ == FALSE, ]
  total_expected <- nrow(expected)
  expected_crossings <- sum(expected[[crossing_var]])
  expected_prop <- expected_crossings / total_expected
  
  # Calculate ratio (accounting for 10:1 sampling of random:observed steps)
  ratio <- observed_prop / expected_prop
  
  # Calculate standard error and 95% CI for the ratio using delta method
  # For proportions: SE = sqrt(p*(1-p)/n)
  se_obs <- sqrt(observed_prop * (1 - observed_prop) / total_observed)
  se_exp <- sqrt(expected_prop * (1 - expected_prop) / total_expected)
  
  # For ratio: using approximation based on propagation of error
  # SE_ratio ≈ ratio * sqrt((SE_obs/obs_prop)^2 + (SE_exp/exp_prop)^2)
  se_ratio <- ratio * sqrt((se_obs/observed_prop)^2 + (se_exp/expected_prop)^2)
  
  # 95% confidence interval for the ratio
  ci_lower <- ratio - 1.96 * se_ratio
  ci_upper <- ratio + 1.96 * se_ratio
  
  # Return results
  result <- data.frame(
    road_type = road_type,
    observed_crossings = observed_crossings,
    expected_crossings = expected_crossings,
    observed_prop = observed_prop,
    expected_prop = expected_prop,
    ratio = ratio,
    ci_lower = ci_lower,
    ci_upper = ci_upper,
    p_value = 2 * pnorm(-abs((ratio - 1)/se_ratio)) # Two-tailed test
  )
  
  return(result)
}

# 2. Apply to different road types
state_ratio <- calculate_crossing_ratio(steps3, "state")
local_ratio <- calculate_crossing_ratio(steps3, "local")

# 3. Combine results
crossing_ratios <- rbind(state_ratio, local_ratio)

# Function to calculate crossing ratios by category
calculate_crossing_ratio_by_category <- function(data, road_type = "state", category_var = "time_category") {
  # Determine which crossing variable to use
  crossing_var <- paste0("crosses_", road_type)
  
  # Get all category levels
  categories <- unique(data[[category_var]])
  results <- data.frame()
  
  for (cat in categories) {
    # Subset data for this category
    cat_data <- data[data[[category_var]] == cat, ]
    
    # Observed crossings
    observed <- cat_data[cat_data$case_ == TRUE, ]
    total_observed <- nrow(observed)
    if (total_observed == 0) next
    observed_crossings <- sum(observed[[crossing_var]])
    observed_prop <- observed_crossings / total_observed
    
    # Expected crossings
    expected <- cat_data[cat_data$case_ == FALSE, ]
    total_expected <- nrow(expected)
    expected_crossings <- sum(expected[[crossing_var]])
    expected_prop <- expected_crossings / total_expected
    
    # Calculate ratio
    ratio <- observed_prop / expected_prop
    
    # Calculate SE and CI
    se_obs <- sqrt(observed_prop * (1 - observed_prop) / total_observed)
    se_exp <- sqrt(expected_prop * (1 - expected_prop) / total_expected)
    se_ratio <- ifelse(
      observed_prop == 0 || expected_prop == 0, 
      NA, 
      ratio * sqrt((se_obs/observed_prop)^2 + (se_exp/expected_prop)^2)
    )
    
    ci_lower <- ratio - 1.96 * se_ratio
    ci_upper <- ratio + 1.96 * se_ratio
    
    # Store results
    cat_result <- data.frame(
      road_type = road_type,
      category = cat,
      category_var = category_var,
      observed_crossings = observed_crossings,
      expected_crossings = expected_crossings,
      total_observed = total_observed,
      total_expected = total_expected,
      observed_prop = observed_prop,
      expected_prop = expected_prop,
      ratio = ratio,
      ci_lower = ci_lower,
      ci_upper = ci_upper
    )
    
    results <- rbind(results, cat_result)
  }
  
  return(results)
}

# Calculate crossing ratios by time of day for each road type
time_state_ratios <- calculate_crossing_ratio_by_category(steps3, "state", "time_category")
time_local_ratios <- calculate_crossing_ratio_by_category(steps3, "local", "time_category")

# Calculate crossing ratios by season for each road type
season_state_ratios <- calculate_crossing_ratio_by_category(steps3, "state", "season")
season_local_ratios <- calculate_crossing_ratio_by_category(steps3, "local", "season")

# 1. Basic crossing ratio plot for road types
ggplot(crossing_ratios, aes(x = road_type, y = log(ratio), fill = road_type)) +
  geom_bar(stat = "identity", width = 0.6) +
  geom_errorbar(aes(ymin = log(ci_lower), ymax = log(ci_upper)), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Season", y = "Log Ratio (Used:Available)",
       title = "Road crossing avoidance by season",
       fill = "") +
  scale_fill_manual(
    values = c("#C4A484", "#C14608"),
    labels = c("Local", "State")
  ) +
    theme_minimal() +
  theme(plot.title=element_text( hjust=0.5, vjust=0.5),
        text = element_text(family = "Times"))

# 2. Crossing ratio by time of day
time_combined <- rbind(
  time_state_ratios %>% mutate(road_group = "State Roads"),
  time_local_ratios %>% mutate(road_group = "Local Roads")
)

ggplot(time_combined, aes(x = category, y = log(ratio), fill = road_group)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_errorbar(aes(ymin = log(ci_lower), ymax = log(ci_upper)), 
                position = position_dodge(width = 0.7), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Season", y = "Log Ratio (Used:Available)",
       title = "Road crossing avoidance by season",
       fill = "") +
  scale_fill_manual(
    values = c("#C4A484", "#E6550D"),
    labels = c("Local", "State")
  ) +
    theme_minimal() +
  theme(plot.title=element_text( hjust=0.5, vjust=0.5),
        text = element_text(family = "Times"))


# 3. Crossing ratio by season
season_combined <- rbind(
  season_state_ratios %>% mutate(road_group = "State Roads"),
  season_local_ratios %>% mutate(road_group = "Local Roads")
)

ggplot(season_combined, aes(x = category, y = log(ratio), fill = road_group)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_errorbar(aes(ymin = log(ci_lower), ymax = log(ci_upper)), 
                position = position_dodge(width = 0.7), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Season", y = "Log ratio (used:available)",
       title = "Road crossing avoidance by season",
       fill = "") +
  scale_fill_manual(
    values = c("#C4A484", "#E6550D"),
    labels = c("Local", "State")
  ) +
    theme_minimal() +
  theme(plot.title=element_text( hjust=0.5, vjust=0.5),
        text = element_text(family = "Times"))


# First, let's combine the data frames
# Add a category_type column to distinguish between time and season data
time_combined$category_type <- "Time of day"
season_combined$category_type <- "Season"

# Combine the data frames
all_crossing_data <- rbind(time_combined, season_combined)

# Create a faceted plot
ggplot(all_crossing_data, aes(x = category, y = log(ratio), fill = road_group)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_errorbar(aes(ymin = log(ci_lower), ymax = log(ci_upper)), 
                position = position_dodge(width = 0.7), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  facet_wrap(~ category_type, scales = "free_x") +
  labs(x = "", y = "Log ratio (used:available)",
       title = "Road crossing avoidance by time of day and season",
       fill = "") +
  scale_fill_manual(
    values = c("#C4A484", "#E6550D"),
    labels = c("Local road", "State road")
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, vjust = 0.5),
    text = element_text(family = "Times"),
    legend.position = "bottom",
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 12, face = "bold")
  )



```






```{r crossing model visualisation}

# Calculate RSS values for each landuse type and crossing status
landuse_levels <- levels(steps3$landuse_factor)

# Create a data frame to store results
rss_data <- data.frame(
  landuse = rep(landuse_levels, each = 2),
  crossing = rep(c("No", "Yes"), times = length(landuse_levels)),
  stringsAsFactors = FALSE
)

# Get coefficients from the model
coefs <- fixef(model_glmm_local)$cond

# Calculate linear predictor for each combination
rss_data$linear_pred <- 0  # Initialize

for (i in 1:nrow(rss_data)) {
  land <- rss_data$landuse[i]
  cross <- rss_data$crossing[i] == "Yes"
  
  # Start with intercept
  pred <- coefs["(Intercept)"]
  
  # Add landuse effect if not reference level (Coniferous)
  if (land != "Coniferous") {
    pred <- pred + coefs[paste0("landuse_factor", land)]
  }
  
  # Add crossing effect and interaction if crossing=Yes
  if (cross) {
    pred <- pred + coefs["crosses_localTRUE"]
    
    # Add interaction if not reference level
    if (land != "Coniferous") {
      interaction_term <- paste0("crosses_localTRUE:landuse_factor", land)
      if (interaction_term %in% names(coefs)) {
        pred <- pred + coefs[interaction_term]
      }
    }
  }
  
  rss_data$linear_pred[i] <- pred
}

# Convert to RSS (relative to no crossing in coniferous)
reference_value <- rss_data$linear_pred[rss_data$landuse == "Coniferous" & 
                                      rss_data$crossing == "No"]
rss_data$rss <- exp(rss_data$linear_pred - reference_value)

# Add jitter for visualization
set.seed(123)
rss_data$x_jitter <- as.numeric(factor(rss_data$crossing)) + 
                   runif(nrow(rss_data), -0.1, 0.1)
rss_data$y_jitter <- rss_data$rss + runif(nrow(rss_data), -0.02, 0.02)


ggplot(rss_data, aes(x = x_jitter, y = y_jitter, shape = landuse, color = landuse)) +
  geom_point(size = 3) +
  scale_x_continuous(breaks = c(1, 2), labels = c("No", "Yes"), 
                    name = "# of crossings") +
  scale_y_continuous(name = "Relative Selection Strength") +
  ggtitle("Relative Selection Strength by Landuse Type and Local Road Crossing") +
  theme_minimal() +
  theme(
    legend.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold", size = 12)
  )




```




```{r probability with CI: time;season;land use; basic}

# Function for basic model with no interactions
calculate_basic_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  effect <- coefs[road_var]
  effect_se <- sqrt(diag(vcov_matrix)[road_var])
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Calculate linear predictor and CI
  linear_pred <- scaled_seq * effect
  linear_ci_lower <- linear_pred - 1.96 * effect_se * abs(scaled_seq)
  linear_ci_upper <- linear_pred + 1.96 * effect_se * abs(scaled_seq)
  
  # Calculate RSS and probability
  rss <- exp(linear_pred)
  rss_lower <- exp(linear_ci_lower)
  rss_upper <- exp(linear_ci_upper)
  
  prob <- rss / (rss + 10)
  prob_lower <- rss_lower / (rss_lower + 10)
  prob_upper <- rss_upper / (rss_upper + 10)
  
  # Store results
  results <- data.frame(
    distance = dist_seq,
    probability = prob,
    prob_lower = prob_lower,
    prob_upper = prob_upper
  )
  
  return(results)
}

# Plot function for basic model
plot_basic <- function(predictions, road_var = "state_d") {
  road_label <- ifelse(grepl("state", road_var), "State Roads", "Local Roads")
  
  ggplot(predictions, aes(x = distance, y = probability)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper), 
                alpha = 0.3, fill = "#1976D2") +
    geom_line(size = 1.2, color = "#1976D2") +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "Basic effect with 95% confidence intervals") +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      plot.title = element_text(face = "bold")
    )
}

# Function for seasonal models
calculate_season_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Define season categories
  season_cats <- levels(data$season)
  all_predictions <- data.frame()
  
  # For each season
  for (season_cat in season_cats) {
    # Calculate effect and SE for this season
    if (season_cat == "Winter") {  # Assuming Winter is the reference level
      effect <- coefs[road_var]
      effect_se <- sqrt(diag(vcov_matrix)[road_var])
    } else {
      # Get the correct interaction term name
      interaction_name <- paste0(road_var, ":season", season_cat)
      if (!(interaction_name %in% names(coefs))) {
        interaction_name <- paste0(road_var, ":factor(season)", season_cat)
      }
      
      # Calculate the combined effect
      effect <- coefs[road_var] + coefs[interaction_name]
      
      # Calculate standard error for combined effect
      main_se <- sqrt(diag(vcov_matrix)[road_var])
      int_se <- sqrt(diag(vcov_matrix)[interaction_name])
      covar <- vcov_matrix[road_var, interaction_name]
      effect_se <- sqrt(main_se^2 + int_se^2 + 2*covar)
    }
    
    # Calculate linear predictor and CIs
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * effect_se * abs(scaled_seq)
    linear_ci_upper <- linear_pred + 1.96 * effect_se * abs(scaled_seq)
    
    # Calculate RSS and probability
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Store results
    season_results <- data.frame(
      distance = dist_seq,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      season = season_cat
    )
    
    all_predictions <- rbind(all_predictions, season_results)
  }
  
  return(all_predictions)
}

# Plot function for seasonal model
plot_season_facet <- function(predictions, road_var = "state_d") {
  road_label <- ifelse(grepl("state", road_var), "State Roads", "Local Roads")
  season_colors <- c("Winter" = "#2196F3", "Spring" = "#4CAF50", "Summer" = "#FF9800")
  
  ggplot(predictions, aes(x = distance, y = probability, color = season)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = season), 
                alpha = 0.3, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ season, nrow = 1) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "By season with 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 12, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = season_colors) +
    scale_fill_manual(values = season_colors)
}



# 1. Function to calculate time predictions with confidence intervals
calculate_time_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # For each time category
  time_cats <- c("Day", "Night", "Twilight")
  all_predictions <- data.frame()
  
  for (time_cat in time_cats) {
    # Calculate effect and SE for this time category
    if (time_cat == "Day") {
      effect <- coefs[road_var]
      effect_se <- sqrt(diag(vcov_matrix)[road_var])
    } else {
      interaction_name <- paste0(road_var, ":factor(time_category)", time_cat)
      effect <- coefs[road_var] + coefs[interaction_name]
      
      # Calculate standard error for combined effect
      main_se <- sqrt(diag(vcov_matrix)[road_var])
      int_se <- sqrt(diag(vcov_matrix)[interaction_name])
      covar <- vcov_matrix[road_var, interaction_name]
      effect_se <- sqrt(main_se^2 + int_se^2 + 2*covar)
    }
    
    # Calculate linear predictor, selection strength, and probability
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * effect_se * abs(scaled_seq)
    linear_ci_upper <- linear_pred + 1.96 * effect_se * abs(scaled_seq)
    
    # Calculate RSS and probability
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Store results
    time_results <- data.frame(
      distance = dist_seq,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      time_category = time_cat
    )
    
    all_predictions <- rbind(all_predictions, time_results)
  }
  
  return(all_predictions)
}

# 2. Plot time predictions with facets
plot_time_facet <- function(predictions, road_type = "state") {
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  time_colors <- c("Day" = "#FFC107", "Night" = "#303F9F", "Twilight" = "#7B1FA2")
  
  ggplot(predictions, aes(x = distance, y = probability, color = time_category)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = time_category), 
                alpha = 0.3, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ time_category, nrow = 1) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "By time of day with 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 12, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = time_colors) +
    scale_fill_manual(values = time_colors)
}

# Updated function for land use interaction models
calculate_landuse_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Define landuse categories (using actual factor levels)
  landuse_cats <- levels(data$landuse_factor)
  all_predictions <- data.frame()
  
  # For each landuse category
  for (landuse_cat in landuse_cats) {
    # Calculate effect and SE for this landuse type
    if (landuse_cat == "Coniferous") {  # Assuming Coniferous is reference level
      effect <- coefs[road_var]
      effect_se <- sqrt(diag(vcov_matrix)[road_var])
    } else {
      # Get the correct interaction term name
      interaction_name <- paste0(road_var, ":landuse_factor", landuse_cat)
      
      # Calculate the combined effect (if interaction exists)
      if (interaction_name %in% names(coefs)) {
        effect <- coefs[road_var] + coefs[interaction_name]
        
        # Calculate standard error for combined effect
        main_se <- sqrt(diag(vcov_matrix)[road_var])
        int_se <- sqrt(diag(vcov_matrix)[interaction_name])
        
        # Safely get covariance
        if (road_var %in% rownames(vcov_matrix) && 
            interaction_name %in% colnames(vcov_matrix)) {
          covar <- vcov_matrix[road_var, interaction_name]
        } else {
          covar <- 0
        }
        
        effect_se <- sqrt(main_se^2 + int_se^2 + 2*covar)
      } else {
        # If no interaction, use base effect
        effect <- coefs[road_var]
        effect_se <- sqrt(diag(vcov_matrix)[road_var])
      }
    }
    
    # Calculate linear predictor and CIs
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * effect_se * abs(scaled_seq)
    linear_ci_upper <- linear_pred + 1.96 * effect_se * abs(scaled_seq)
    
    # Calculate RSS and probability
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Store results
    landuse_results <- data.frame(
      distance = dist_seq,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      landuse = landuse_cat
    )
    
    all_predictions <- rbind(all_predictions, landuse_results)
  }
  
  return(all_predictions)
}

# Updated plot function to include confidence intervals
plot_landuse_facet <- function(predictions, road_var = "state_d") {
  road_label <- ifelse(grepl("state", road_var), "State Roads", "Local Roads")
  
  # Define colors for different landuse types
  landuse_colors <- c(
    "Coniferous" = "#2E7D32",        # Dark green
    "Mixed" = "#558B2F",             # Medium green
    "Deciduous" = "#8BC34A",         # Light green
    "Open/shrub/bog" = "#FDD835",    # Yellow
    "New forest" = "#81C784",        # Pale green
    "Human-modified" = "#E57373"     # Red
  )
  
  ggplot(predictions, aes(x = distance, y = probability, color = landuse)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = landuse), 
                alpha = 0.2, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ landuse, nrow = 2) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "By land use type with 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 10, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = landuse_colors) +
    scale_fill_manual(values = landuse_colors)
}


# 1. Time of Day effect (using model_glmm3.0.1)
state_time_preds <- calculate_time_ci(model_glmm3.0.1, steps3, "state_d")
state_time_plot <- plot_time_facet(state_time_preds, "state_d")
print(state_time_plot)

local_time_preds <- calculate_time_ci(model_glmm3.0.1, steps3, "local_d")
local_time_plot <- plot_time_facet(local_time_preds, "local_d")
print(local_time_plot)

# 2. Seasonal effect (using model_glmm2.0.3)
state_season_preds <- calculate_season_ci(model_glmm2.0.2, steps3, "state_d")
state_season_plot <- plot_season_facet(state_season_preds, "state_d")
print(state_season_plot)

local_season_preds <- calculate_season_ci(model_glmm2.0.3, steps3, "local_d")
local_season_plot <- plot_season_facet(local_season_preds, "local_d")
print(local_season_plot)

# 3. Landuse interaction (using model_glmm_state.1 and model_glmm_local.1)
state_landuse_preds <- calculate_landuse_ci(model_glmm_state.1, steps3, "state_d")
state_landuse_plot <- plot_landuse_facet(state_landuse_preds, "state_d")
print(state_landuse_plot)

local_landuse_preds <- calculate_landuse_ci(model_glmm_local.1, steps3, "local_d")
local_landuse_plot <- plot_landuse_facet(local_landuse_preds, "local_d")
print(local_landuse_plot)

# 4. Basic road effect (using model_glmm1.1.1)
state_basic_preds <- calculate_basic_ci(model_glmm1.1.1, steps3, "state_d")
state_basic_plot <- plot_basic(state_basic_preds, "state_d")
print(state_basic_plot)

local_basic_preds <- calculate_basic_ci(model_glmm1.1.1, steps3, "local_d")
local_basic_plot <- plot_basic(local_basic_preds, "local_d")
print(local_basic_plot)


```


```{r new CI probabilities}

# Simplified visualization code for moose habitat selection models

# 1. Function for basic model with no interactions
calculate_basic_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters - calculate directly
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  
  # Find the coefficient
  effect <- coefs[road_var]
  effect_se <- sqrt(diag(vcov_matrix)[road_var])
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Calculate linear predictor and CI
  linear_pred <- scaled_seq * effect
  linear_ci_lower <- linear_pred - 1.96 * effect_se * abs(scaled_seq)
  linear_ci_upper <- linear_pred + 1.96 * effect_se * abs(scaled_seq)
  
  # Calculate RSS and probability
  rss <- exp(linear_pred)
  rss_lower <- exp(linear_ci_lower)
  rss_upper <- exp(linear_ci_upper)
  
  prob <- rss / (rss + 10)
  prob_lower <- rss_lower / (rss_lower + 10)
  prob_upper <- rss_upper / (rss_upper + 10)
  
  # Store results
  results <- data.frame(
    distance = dist_seq,
    probability = prob,
    prob_lower = prob_lower,
    prob_upper = prob_upper
  )
  
  return(results)
}

# 2. Function for time of day models
calculate_time_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters - calculate directly
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # For each time category
  time_cats <- c("Day", "Night", "Twilight")
  all_predictions <- data.frame()
  
  for (time_cat in time_cats) {
    # Calculate effect and SE for this time category
    if (time_cat == "Day") {
      effect <- coefs[road_var]
      effect_se <- sqrt(diag(vcov_matrix)[road_var])
    } else {
      # The interaction term uses time_category (not factor(time_category))
      interaction_name <- paste0(road_var, ":time_category", time_cat)
      
      effect <- coefs[road_var] + coefs[interaction_name]
      
      # Calculate standard error for combined effect
      main_se <- sqrt(diag(vcov_matrix)[road_var])
      int_se <- sqrt(diag(vcov_matrix)[interaction_name])
      covar <- vcov_matrix[road_var, interaction_name]
      effect_se <- sqrt(main_se^2 + int_se^2 + 2*covar)
    }
    
    # Calculate linear predictor, selection strength, and probability
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * effect_se * abs(scaled_seq)
    linear_ci_upper <- linear_pred + 1.96 * effect_se * abs(scaled_seq)
    
    # Calculate RSS and probability
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Store results
    time_results <- data.frame(
      distance = dist_seq,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      time_category = time_cat
    )
    
    all_predictions <- rbind(all_predictions, time_results)
  }
  
  return(all_predictions)
}

# 3. Function for seasonal models
calculate_season_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters - calculate directly
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Define season categories
  season_cats <- levels(data$season)
  all_predictions <- data.frame()
  
  # For each season
  for (season_cat in season_cats) {
    # Calculate effect and SE for this season
    if (season_cat == "Winter") {  # Winter is the reference level
      effect <- coefs[road_var]
      effect_se <- sqrt(diag(vcov_matrix)[road_var])
    } else {
      # Get the interaction term
      interaction_name <- paste0(road_var, ":season", season_cat)
      
      # Calculate the combined effect
      effect <- coefs[road_var] + coefs[interaction_name]
      
      # Calculate standard error for combined effect
      main_se <- sqrt(diag(vcov_matrix)[road_var])
      int_se <- sqrt(diag(vcov_matrix)[interaction_name])
      covar <- vcov_matrix[road_var, interaction_name]
      effect_se <- sqrt(main_se^2 + int_se^2 + 2*covar)
    }
    
    # Calculate linear predictor and CIs
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * effect_se * abs(scaled_seq)
    linear_ci_upper <- linear_pred + 1.96 * effect_se * abs(scaled_seq)
    
    # Calculate RSS and probability
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Store results
    season_results <- data.frame(
      distance = dist_seq,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      season = season_cat
    )
    
    all_predictions <- rbind(all_predictions, season_results)
  }
  
  return(all_predictions)
}

# 4. Function for landuse interaction models
calculate_landuse_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters - calculate directly
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Define landuse categories (using actual factor levels)
  landuse_cats <- levels(data$landuse_factor)
  all_predictions <- data.frame()
  
  # Coniferous is always the reference level
  ref_level <- "Coniferous" 
  
  # For each landuse category
  for (landuse_cat in landuse_cats) {
    # Calculate effect and SE for this landuse type
    if (landuse_cat == ref_level) {
      effect <- coefs[road_var]
      effect_se <- sqrt(diag(vcov_matrix)[road_var])
    } else {
      # Get the correct interaction term name
      interaction_name <- paste0(road_var, ":landuse_factor", landuse_cat)
      
      # Calculate the combined effect (if interaction exists)
      if (interaction_name %in% names(coefs)) {
        effect <- coefs[road_var] + coefs[interaction_name]
        
        # Calculate standard error for combined effect
        main_se <- sqrt(diag(vcov_matrix)[road_var])
        int_se <- sqrt(diag(vcov_matrix)[interaction_name])
        covar <- vcov_matrix[road_var, interaction_name]
        effect_se <- sqrt(main_se^2 + int_se^2 + 2*covar)
      } else {
        # If no interaction, use base effect
        effect <- coefs[road_var]
        effect_se <- sqrt(diag(vcov_matrix)[road_var])
      }
    }
    
    # Calculate linear predictor and CIs
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * effect_se * abs(scaled_seq)
    linear_ci_upper <- linear_pred + 1.96 * effect_se * abs(scaled_seq)
    
    # Calculate RSS and probability
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Store results
    landuse_results <- data.frame(
      distance = dist_seq,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      landuse = landuse_cat
    )
    
    all_predictions <- rbind(all_predictions, landuse_results)
  }
  
  return(all_predictions)
}

# Plotting functions - unchanged from original

# Plot function for basic model
plot_basic <- function(predictions, road_var = "state_d") {
  road_label <- ifelse(grepl("state", road_var), "State Roads", "Local Roads")
  
  ggplot(predictions, aes(x = distance, y = probability)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper), 
                alpha = 0.3, fill = "#1976D2") +
    geom_line(size = 1.2, color = "#1976D2") +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "Basic effect with 95% confidence intervals") +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      plot.title = element_text(face = "bold")
    )
}

# Plot function for time of day
plot_time_facet <- function(predictions, road_type = "state") {
  road_label <- ifelse(grepl("state", road_type), "State Roads", "Local Roads")
  time_colors <- c("Day" = "#FFC107", "Night" = "#303F9F", "Twilight" = "#7B1FA2")
  
  ggplot(predictions, aes(x = distance, y = probability, color = time_category)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = time_category), 
                alpha = 0.3, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ time_category, nrow = 1) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "By time of day with 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 12, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = time_colors) +
    scale_fill_manual(values = time_colors)
}

# Plot function for seasonal model
plot_season_facet <- function(predictions, road_var = "state_d") {
  road_label <- ifelse(grepl("state", road_var), "State Roads", "Local Roads")
  season_colors <- c("Winter" = "#2196F3", "Spring" = "#4CAF50", "Summer" = "#FF9800")
  
  ggplot(predictions, aes(x = distance, y = probability, color = season)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = season), 
                alpha = 0.3, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ season, nrow = 1) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "By season with 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 12, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = season_colors) +
    scale_fill_manual(values = season_colors)
}

# Plot function for landuse model
plot_landuse_facet <- function(predictions, road_var = "state_d") {
  road_label <- ifelse(grepl("state", road_var), "State Roads", "Local Roads")
  
  # Define colors for different landuse types
  landuse_colors <- c(
    "Coniferous" = "#2E7D32",        # Dark green
    "Mixed" = "#558B2F",             # Medium green
    "Deciduous" = "#8BC34A",         # Light green
    "Open/shrub/bog" = "#FDD835",    # Yellow
    "New forest" = "#81C784",        # Pale green
    "Human-modified" = "#E57373"     # Red
  )
  
  ggplot(predictions, aes(x = distance, y = probability, color = landuse)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = landuse), 
                alpha = 0.2, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ landuse, nrow = 2) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "By land use type with 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 10, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = landuse_colors) +
    scale_fill_manual(values = landuse_colors)
}

# Example usage for each model type:

# 1. Time of Day effect
state_time_preds <- calculate_time_ci(model_glmm3_3.0.2, steps3, "s_state_d")
state_time_plot <- plot_time_facet(state_time_preds, "state")
print(state_time_plot)

local_time_preds <- calculate_time_ci(model_glmm3_3.0.2, steps3, "s_local_d")
local_time_plot <- plot_time_facet(local_time_preds, "local")
print(local_time_plot)

# 2. Seasonal effect
state_season_preds <- calculate_season_ci(model_glmm2.0, steps3, "s_state_d")
state_season_plot <- plot_season_facet(state_season_preds, "state_d")
print(state_season_plot)

local_season_preds <- calculate_season_ci(model_glmm2.0, steps3, "s_local_d")
local_season_plot <- plot_season_facet(local_season_preds, "local_d")
print(local_season_plot)

# 3. Landuse interaction
state_landuse_preds <- calculate_landuse_ci(model_glmm_state.2, steps3, "s_state_d")
state_landuse_plot <- plot_landuse_facet(state_landuse_preds, "state_d")
print(state_landuse_plot)

local_landuse_preds <- calculate_landuse_ci(model_glmm_local.2, steps3, "s_local_d")
local_landuse_plot <- plot_landuse_facet(local_landuse_preds, "local_d")
print(local_landuse_plot)

# 4. Basic road effect
state_basic_preds <- calculate_basic_ci(model_glmm1.1.1, steps3, "s_state_d")
state_basic_plot <- plot_basic(state_basic_preds, "state_d")
print(state_basic_plot)

local_basic_preds <- calculate_basic_ci(model_glmm1.1.1, steps3, "s_local_d")
local_basic_plot <- plot_basic(local_basic_preds, "local_d")
print(local_basic_plot)


```
