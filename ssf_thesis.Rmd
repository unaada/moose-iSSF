---
title: "ssf_thesis"
author: "Una Adamoviča"
date: "2025-03-05"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(suncalc)
library(chron)

library(sf)
library(terra)
library(tidyverse)
library(lubridate)
library(corrplot)

library(amt)
library(glmmTMB)

```


```{r workflow}

### collect covariates
# distance to road per class
# land cover: different forest types, open, anthropogenic, water, new forest
# time of day:distance_to_road and time:crossing(y/n)
# season - after decding which models, then build for 3 seasons?
# -- perhaps -- make also the angle analysis = avoidance, attraction, corridor



```



```{r preperation of moose data, echo=TRUE}

moose <- read.csv("moose_df.csv")

# clean and make tracks 
moose <- moose %>% 
  mutate(timestamp = as.POSIXct(as.character(timestamp),  format = "%Y-%m-%d %H:%M:%S")) %>%
  filter(!is.na(timestamp)) %>% 
  make_track(UTM.Easting, UTM.Northing, timestamp, crs = 3301, id = id)

head(moose, 5)

# # A tibble: 5 × 4
#        x_       y_ t_                     id
# *   <dbl>    <dbl> <dttm>              <int>
# 1 591225. 6545176. 2018-11-23 22:30:18 39789
# 2 591250. 6545167. 2018-11-23 23:00:08 39789
# 3 591337. 6545008. 2018-11-23 23:30:16 39789
# 4 591292. 6544921. 2018-11-24 00:00:11 39789
# 5 591238. 6545135. 2018-11-24 00:30:30 39789

summarize_sampling_rate_many(moose, "id")

# make manipulations of moose data
moose_sf <- st_as_sf(moose, coords = c("x_", "y_"), crs = 3301) 

# create lines
moose_lines <- moose_sf %>%
  group_by(id) %>%
  summarize(do_union = FALSE) %>%
  st_cast("LINESTRING")
plot(moose_lines)

# create study area to clip everyhting
study_area <- moose_sf %>%
  st_buffer(dist = 1823) %>%
  st_union() %>%
  st_as_sf()

# remove the points when animals are resting
points_to_keep <- moose_sf %>%
  group_by(id) %>%
  mutate(
    distance = as.numeric(st_distance(geometry, lead(geometry), by_element = TRUE)),
    keep_point = !is.na(distance) & distance > 18
  ) %>%
  pull(keep_point)

moose_filter <- moose[points_to_keep, ]
head(moose_filter, 5)

# > head(moose_filter, 5)
# # A tibble: 5 × 4
#        x_       y_ t_                     id
# *   <dbl>    <dbl> <dttm>              <int>
# 1 591225. 6545176. 2018-11-23 22:30:18 39789
# 2 591250. 6545167. 2018-11-23 23:00:08 39789
# 3 591337. 6545008. 2018-11-23 23:30:16 39789
# 4 591292. 6544921. 2018-11-24 00:00:11 39789
# 5 591238. 6545131. 2018-11-24 03:00:15 39789

# list-column to make it easy to apply functions to each animal data seperately 
dat1 <- moose_filter %>% nest(data = -id)
head(dat1,8)

# > head(dat1,8)
# # A tibble: 8 × 2
#      id data                  
#   <int> <list>                
# 1 39789 <trck_xyt [4,548 × 3]>
# 2 39787 <trck_xyt [6,073 × 3]>
# 3 39785 <trck_xyt [5,870 × 3]>
# 4 39788 <trck_xyt [5,140 × 3]>
# 5 39793 <trck_xyt [5,894 × 3]>
# 6 39791 <trck_xyt [5,780 × 3]>
# 7 39790 <trck_xyt [5,464 × 3]>
# 8 39794 <trck_xyt [6,430 × 3]>

# resample to have everything consistent
dat2 <- dat1 %>% 
  mutate(dat.resample = map(data, ~ track_resample(., 
                                                   rate = lubridate::minutes(30), 
                                                   tolerance = lubridate::minutes(2)))) 

head(dat2)
```


```{r collecting covariates}
#layers

new_forest <- rast("D:\\Users\\amand\\Documents\\qgis\\masters_data\\Hansen_GFC-2022-v1.10_lossyear_60N_020E.tif")

roads <- st_read("D:\\Users\\amand\\Documents\\qgis\\masters_qgis\\vectors\\full-road-classes.gpkg")

corine <- rast("D:\\Users\\amand\\Documents\\qgis\\masters_qgis\\rasters\\corine_30m_resample_mode.tif")

#### 1. landuse
# reclassify matrix to group landuse categories
m <- matrix(c(0,22,1,
              22,23, 2,
              23, 24, 3,
              24, 25, 4,
              25, 41, 5), ncol = 3, byrow = TRUE)

# 1 = human-modified = agriculture and anthropogenic
# 2 = broad-leaved (deciduous)
# 3 = coniferous
# 4 = mixed
# 5 = open areas -> combine with srub and peatbog and water
# lowest excluded, maximum included

landuse <- terra::classify(corine, m) %>%
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("landuse")

#### 2. roads + distance
# distance to roads code
  # mutate(
  #   nearest_major = st_distance(geometry,st_union(roads[roads$class>= 2, ])),
  #   nearest_minor = st_distance(geometry, st_union(roads[roads$class== 1, ])),
  #   nearest_local = st_distance(geometry, st_union(roads[roads$class == 0, ]))
  # )

major_roads_dist <- roads[roads$class >= 2,] %>%
  rasterize(landuse) %>%
  distance() %>% 
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("major_d")

minor_roads_dist <- roads[roads$class == 1,] %>%
  rasterize(landuse) %>%
  distance() %>% 
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("minor_d")

local_roads_dist <- roads[roads$class == 0,] %>%
  rasterize(landuse) %>%
  distance() %>% 
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("local_d")


#### 3. new forest (forest loss)
# reproject the layer, align the grids, and assign binary values to have new forest y/n
new_forest <- new_forest %>% 
  project(landuse) %>% 
  resample(landuse, method = "near") %>% 
  classify(matrix(c(3, 16, 1,
                    16, 22, 0), ncol = 3, byrow = TRUE)) %>% 
  crop(study_area) %>% 
  mask(study_area) %>% 
  setNames("new_forest")

# where new forest is 
mask_new_forest <- new_forest == 1

landuse_in_newforest <- mask(landuse, mask_new_forest)

freq_table <- terra::freq(landuse_in_newforest)
total_pixels <- sum(freq_table$count, na.rm = TRUE)
freq_table$percentage <- (freq_table$count / total_pixels) * 100

# > freq_table
#   layer value  count percentage
# 1     1     1 123684  24.021255
# 2     1     2  11752   2.282412
# 3     1     3 126907  24.647209
# 4     1     4 130521  25.349101
# 5     1     5 122030  23.700024

# where forest is in landuse
forest_types <- landuse %in% c(2, 3, 4, 5)
forest_to_override <- forest_types & mask_new_forest

landuse_total <- landuse %>% 
  setNames("landuse_total")
landuse_total[forest_to_override] <- 6

freq_before <- terra::freq(landuse)
freq_after <- terra::freq(landuse_total)
print(data.frame(
  Category = c("Human-modified", "Deciduous", "Coniferous", "Mixed", "Open/shrub/bog", "New forest"),
  Before = c(freq_before$count, 0),  # Add 0 for the new category that didn't exist before
  After = freq_after$count
))

#### 4. time 



```


```{r all moose}

# remove for each moose if burst < 3
dat3 <- dat2 %>%
  mutate(dat.filtered = map(dat.resample, ~ filter_min_n_burst(., min_n = 3)))
# try to retain the filtered AND the id columns
all_moose <- map2_dfr(dat3$dat.filtered, dat3$id, ~{
  .x %>% mutate(id = .y)
})
# again it wants to remove the id, so make map
burst_id_map <- as.data.frame(all_moose) %>%
  dplyr::select(id, burst_) %>%
  distinct()
# regular generation of steps
steps <- all_moose %>%
  steps_by_burst() %>%
  random_steps(n_control = 10, 
              sl_distr = fit_distr(.$sl_, "gamma"),
              ta_distr = fit_distr(.$ta_, "vonmises"), 
              include_observed = TRUE) %>% 
  remove_incomplete_strata()

# try to join back the moose id to have for glmmm as random effect
steps <- steps %>%
  left_join(burst_id_map, by = "burst_", relationship = "many-to-one", multiple = "first")

# get the covariates for each step
steps2 <- steps %>% 
  extract_covariates(landuse_total) %>% 
  extract_covariates(major_roads_dist) %>%
  extract_covariates(minor_roads_dist) %>%
  extract_covariates(local_roads_dist)


#  time categories
steps2 <- steps2 %>%
  mutate(
    time_of_day = chron(times = format(t1_, format = "%H:%M:%S")),
    date = as.Date(t1_, format = "%Y/%m/%d")
  ) 

# get time of day times to assign time categories
sunlight <- getSunlightTimes(
  date = steps2$date,
  lon = 25.45, 
  lat = 59.05, 
  keep = c("sunrise", "sunset", "dawn", "dusk"),
  tz = "Europe/Tallinn"
)

steps3 <- steps2 %>%
  # join to get the time of sunglight for each observation
  left_join(sunlight, by = "date", relationship = "many-to-many", multiple = "first") %>%
  
  # assign time category for each observation based on sunlight availability
  mutate(
    sunrise = chron(times = format(sunrise, format = "%H:%M:%S")),
    sunset = chron(times = format(sunset, format = "%H:%M:%S")),
    dawn = chron(times = format(dawn, format = "%H:%M:%S")),
    dusk = chron(times = format(dusk, format = "%H:%M:%S")),
    
    time_category = case_when(
      time_of_day >= sunrise & time_of_day < sunset ~ "Day", # day
      (time_of_day >= dawn & time_of_day < sunrise) | 
        (time_of_day >= sunset & time_of_day < dusk) ~ "Twilight", # twilight
      TRUE ~ "Night"), #night
    
    month = lubridate::month(t1_, label = TRUE),
    
    # assign season category
    season = case_when(
      month %in% c("Nov","Dec", "Jan", "Feb","Mar") ~ "Winter", #winter
      month %in% c( "Apr", "May") ~ "Spring", #spring
      month %in% c("Jun", "Jul", "Aug", "Sep") ~ "Summer" #summer
    ),
    
    # insert state road distances (major + minor class) 
    state_d = pmin(minor_d, major_d, na.rm = TRUE)

  ) %>%
  
  # remove some unnecessary attributes
  dplyr::select(-sunrise, -sunset, -dawn, -dusk, -lon, -lat)


# steffanie suggestion how to structure data for injection
d.map <- data.frame(step_id_=unique(steps3$step_id_), 
                    str_ID=1:length(unique(steps3$step_id_)))

# put new sequential stratum ID
steps3$str_ID <- d.map[match(steps3$step_id_, d.map$step_id_), "str_ID"]

# ordering data by stratum id
steps3 <- steps3[order(steps3$str_ID),]

# give meaningful names and give reference category
steps3$landuse_factor <- factor(steps3$landuse_total,
                                labels = c("Human-modified", "Deciduous",
                                           "Coniferous", "Mixed", "Open/shrub/bog", "New forest")) %>% 
  relevel(ref = "Coniferous")

# 1 = human-modified = agriculture and anthropogenic
# 2 = broad-leaved (deciduous)
# 3 = coniferous
# 4 = mixed
# 5 = open areas -> combine with shrub and peatbog and water
# 6 = new forest 

# change reference category
steps3$time_category <- factor(steps3$time_category) %>% relevel(ref = "Day")
steps3$season <- factor(steps3$season) %>% relevel(ref = "Summer")

# create an original (before scaling) variable
steps3_original <- steps3

# scale the continuous variables for convergance and making them comparable
steps3$log_sl_ <- scale(log(steps3$sl_))
steps3$cos_ta_ <- scale(cos(steps3$ta_))
steps3$minor_d <- scale(steps3$minor_d)
steps3$major_d <- scale(steps3$major_d)
steps3$local_d <- scale(steps3$local_d)
steps3$state_d <- scale(steps3$state_d)


```



```{r base movement model}


#----------------------------------------------------- glmm ----------------------------------------------------

# Define GLMM structure without fitting
TMBStruc1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    minor_d + major_d + local_d + 
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

# put variance 1e3, so SD would be 1e6
TMBStruc1$parameters$theta[1] = log(1e3)  

# assign that the variance would not be estimated for the first random effect 
TMBStruc1$mapArg = list(theta = factor(c(NA, 1)))

# now finally fit the model
model_glmm1 <- glmmTMB:::fitTMB(TMBStruc1)

summary(model_glmm1)
#       AIC       BIC    logLik  deviance  df.resid 
#  404858.6  404982.0 -202417.3  404834.6    216424 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.456e-01    0.3815
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.071939   7.132094  -0.431 0.666672    
# log_sl_                       0.132789   0.007886  16.838  < 2e-16 ***
# cos_ta_                       0.005916   0.007515   0.787 0.431168    
# minor_d                       0.320127   0.091586   3.495 0.000473 ***
# major_d                       0.102621   0.096825   1.060 0.289206    
# local_d                       0.100907   0.022810   4.424 9.69e-06 ***
# landuse_factorHuman-modified -0.300330   0.046139  -6.509 7.55e-11 ***
# landuse_factorDeciduous       0.279953   0.053742   5.209 1.90e-07 ***
# landuse_factorMixed           0.059922   0.032891   1.822 0.068478 .  
# landuse_factorOpen/shrub/bog  0.047734   0.039162   1.219 0.222879    
# landuse_factorNew forest      0.362773   0.027340  13.269  < 2e-16 ***


# ---- basic with 2 road categories -------

TMBStruc1.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    state_d + local_d + 
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc1.1$parameters$theta[1] = log(1e3)  
TMBStruc1.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm1.1 <- glmmTMB:::fitTMB(TMBStruc1.1)
summary(model_glmm1.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404844.8  404958.0 -202411.4  404822.8    216425 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.473e-01    0.3838
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.064817   7.132135  -0.430 0.667400    
# log_sl_                       0.132740   0.007886  16.833  < 2e-16 ***
# cos_ta_                       0.006048   0.007515   0.805 0.420950    
# state_d                       0.418331   0.080042   5.226 1.73e-07 ***
# local_d                       0.087488   0.022806   3.836 0.000125 ***
# landuse_factorHuman-modified -0.299990   0.046118  -6.505 7.78e-11 ***
# landuse_factorDeciduous       0.279702   0.053712   5.207 1.91e-07 ***
# landuse_factorMixed           0.064030   0.032898   1.946 0.051613 .  
# landuse_factorOpen/shrub/bog  0.048239   0.039133   1.233 0.217695    
# landuse_factorNew forest      0.366527   0.027347  13.403  < 2e-16 ***

# ----------------------------------------- basic with 2 road categories -1 -------------------------

TMBStruc1.1.1 <- glmmTMB(
  case_ ~ log_sl_ +
    state_d + local_d + 
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc1.1.1$parameters$theta[1] = log(1e3)  
TMBStruc1.1.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm1.1.1 <- glmmTMB:::fitTMB(TMBStruc1.1.1)
summary(model_glmm1.1.1)


#       AIC       BIC    logLik  deviance  df.resid 
#  404843.5  404946.3 -202411.7  404823.5    216426 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.442e-01    0.3797
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.064424   7.132073  -0.430 0.667437    
# log_sl_                       0.132837   0.007885  16.847  < 2e-16 ***
# state_d                       0.417200   0.079978   5.216 1.82e-07 ***
# local_d                       0.086828   0.022778   3.812 0.000138 ***
# landuse_factorHuman-modified -0.298716   0.046077  -6.483 8.99e-11 ***
# landuse_factorDeciduous       0.279859   0.053701   5.211 1.87e-07 ***
# landuse_factorMixed           0.064163   0.032890   1.951 0.051079 .  
# landuse_factorOpen/shrub/bog  0.048561   0.039121   1.241 0.214498    
# landuse_factorNew forest      0.366657   0.027342  13.410  < 2e-16 ***

# --- landuse local -----

TMBStruc_local <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ +
    local_d + 
    landuse_factor + local_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_local$parameters$theta[1] = log(1e3)  
TMBStruc_local$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_local <- glmmTMB:::fitTMB(TMBStruc_local)
summary(model_glmm_local)

#       AIC       BIC    logLik  deviance  df.resid 
#  404838.2  404992.4 -202404.1  404808.2    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.466e-01    0.3829
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                       Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                          -3.045878   7.132105  -0.427 0.669331    
# log_sl_                               0.132559   0.007898  16.784  < 2e-16 ***
# cos_ta_                              -0.001705   0.007504  -0.227 0.820242    
# local_d                               0.071406   0.029187   2.447 0.014424 *  
# landuse_factorHuman-modified         -0.253319   0.072354  -3.501 0.000463 ***
# landuse_factorDeciduous               0.212535   0.057964   3.667 0.000246 ***
# landuse_factorMixed                   0.038704   0.033362   1.160 0.245996    
# landuse_factorOpen/shrub/bog          0.013277   0.039572   0.336 0.737240    
# landuse_factorNew forest              0.348281   0.027564  12.635  < 2e-16 ***
# local_d:landuse_factorHuman-modified  0.163555   0.076012   2.152 0.031421 *  
# local_d:landuse_factorDeciduous       0.153461   0.051740   2.966 0.003017 ** 
# local_d:landuse_factorMixed           0.062369   0.033633   1.854 0.063679 .  
# local_d:landuse_factorOpen/shrub/bog  0.011843   0.033079   0.358 0.720327    
# local_d:landuse_factorNew forest      0.001285   0.028103   0.046 0.963524  

# remove non significant 

TMBStruc_local.1 <- glmmTMB(
  case_ ~ log_sl_ +
    local_d + 
    landuse_factor + local_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_local.1$parameters$theta[1] = log(1e3)  
TMBStruc_local.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_local.1 <- glmmTMB:::fitTMB(TMBStruc_local.1)
summary(model_glmm_local.1)


#       AIC       BIC    logLik  deviance  df.resid 
#  404836.2  404980.2 -202404.1  404808.2    216422 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.449e-01    0.3807
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                       Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                          -3.042015   7.132083  -0.427 0.669725    
# log_sl_                               0.132529   0.007897  16.782  < 2e-16 ***
# local_d                               0.071628   0.029177   2.455 0.014091 *  
# landuse_factorHuman-modified         -0.253532   0.072349  -3.504 0.000458 ***
# landuse_factorDeciduous               0.212455   0.057967   3.665 0.000247 ***
# landuse_factorMixed                   0.038709   0.033364   1.160 0.245960    
# landuse_factorOpen/shrub/bog          0.013200   0.039572   0.334 0.738711    
# landuse_factorNew forest              0.348248   0.027565  12.634  < 2e-16 ***
# local_d:landuse_factorHuman-modified  0.163639   0.076016   2.153 0.031343 *  
# local_d:landuse_factorDeciduous       0.153401   0.051743   2.965 0.003030 ** 
# local_d:landuse_factorMixed           0.062354   0.033634   1.854 0.063754 .  
# local_d:landuse_factorOpen/shrub/bog  0.011819   0.033081   0.357 0.720893    
# local_d:landuse_factorNew forest      0.001241   0.028104   0.044 0.964779   

# ---- landuse state -----

TMBStruc_state<- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ +
    state_d + 
    landuse_factor + state_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_state$parameters$theta[1] = log(1e3)  
TMBStruc_state$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_state <- glmmTMB:::fitTMB(TMBStruc_state)
summary(model_glmm_state)


#       AIC       BIC    logLik  deviance  df.resid 
#  404788.0  404942.3 -202379.0  404758.0    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.491e-01    0.3861
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                       Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                          -3.052847   7.132173  -0.428   0.6686    
# log_sl_                               0.133742   0.007906  16.917  < 2e-16 ***
# cos_ta_                              -0.001800   0.007501  -0.240   0.8103    
# state_d                               0.352513   0.082430   4.276 1.90e-05 ***
# landuse_factorHuman-modified         -0.347560   0.046364  -7.496 6.56e-14 ***
# landuse_factorDeciduous               0.341565   0.058738   5.815 6.06e-09 ***
# landuse_factorMixed                   0.043346   0.033214   1.305   0.1919    
# landuse_factorOpen/shrub/bog          0.030638   0.039507   0.775   0.4380    
# landuse_factorNew forest              0.356184   0.027475  12.964  < 2e-16 ***
# state_d:landuse_factorHuman-modified  0.227468   0.041940   5.424 5.84e-08 ***
# state_d:landuse_factorDeciduous       0.188404   0.078443   2.402   0.0163 *  
# state_d:landuse_factorMixed          -0.056539   0.033010  -1.713   0.0868 .  
# state_d:landuse_factorOpen/shrub/bog -0.018481   0.038412  -0.481   0.6304    
# state_d:landuse_factorNew forest      0.014158   0.028968   0.489   0.6250    

# remove non significant parameter

TMBStruc_state.1<- glmmTMB(
  case_ ~ log_sl_ +
    state_d + 
    landuse_factor + state_d:landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc_state.1$parameters$theta[1] = log(1e3)  
TMBStruc_state.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_state.1 <- glmmTMB:::fitTMB(TMBStruc_state.1)
summary(model_glmm_state.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404786.1  404930.1 -202379.0  404758.1    216422 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.478e-01    0.3844
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                       Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                          -3.049987   7.132128  -0.428   0.6689    
# log_sl_                               0.133740   0.007905  16.919  < 2e-16 ***
# state_d                               0.352894   0.082429   4.281 1.86e-05 ***
# landuse_factorHuman-modified         -0.347955   0.046343  -7.508 5.99e-14 ***
# landuse_factorDeciduous               0.341552   0.058742   5.814 6.08e-09 ***
# landuse_factorMixed                   0.043290   0.033215   1.303   0.1925    
# landuse_factorOpen/shrub/bog          0.030553   0.039508   0.773   0.4393    
# landuse_factorNew forest              0.356126   0.027476  12.961  < 2e-16 ***
# state_d:landuse_factorHuman-modified  0.227555   0.041941   5.426 5.78e-08 ***
# state_d:landuse_factorDeciduous       0.188439   0.078448   2.402   0.0163 *  
# state_d:landuse_factorMixed          -0.056560   0.033011  -1.713   0.0866 .  
# state_d:landuse_factorOpen/shrub/bog -0.018549   0.038415  -0.483   0.6292    
# state_d:landuse_factorNew forest      0.014118   0.028969   0.487   0.6260  


# ----------------------------------------- basic with quadratic terms -------------------------------

steps3$state_d_sq <- steps3$state_d^2
steps3$local_d_sq <- steps3$local_d^2

TMBStruc1.2 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    state_d + state_d_sq +
    local_d + local_d_sq +
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc1.2$parameters$theta[1] = log(1e3)  
TMBStruc1.2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm1.2 <- glmmTMB:::fitTMB(TMBStruc1.2)
summary(model_glmm1.2)


#       AIC       BIC    logLik  deviance  df.resid 
#  404816.1  404949.8 -202395.0  404790.1    216423 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.464e-01    0.3826
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -2.915826   7.132236  -0.409   0.6827    
# log_sl_                       0.133659   0.007890  16.940  < 2e-16 ***
# cos_ta_                       0.007065   0.007520   0.940   0.3475    
# state_d                       0.459203   0.080473   5.706 1.15e-08 ***
# state_d_sq                   -0.096926   0.041649  -2.327   0.0200 *  
# local_d                       0.104419   0.023359   4.470 7.81e-06 ***
# local_d_sq                   -0.063529   0.012122  -5.241 1.60e-07 ***
# landuse_factorHuman-modified -0.265646   0.046553  -5.706 1.15e-08 ***
# landuse_factorDeciduous       0.286945   0.053815   5.332 9.71e-08 ***
# landuse_factorMixed           0.064955   0.032945   1.972   0.0487 *  
# landuse_factorOpen/shrub/bog  0.054153   0.039163   1.383   0.1667    
# landuse_factorNew forest      0.367683   0.027365  13.436  < 2e-16 ***

# ---------------------------------------------------- basic quadratic -1 ------------------------------

TMBStruc1.2.1 <- glmmTMB(
  case_ ~ log_sl_ +
    state_d + state_d_sq +
    local_d + local_d_sq +
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc1.2.1$parameters$theta[1] = log(1e3)  
TMBStruc1.2.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm1.2.1 <- glmmTMB:::fitTMB(TMBStruc1.2.1)
summary(model_glmm1.2.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404815.0  404938.4 -202395.5  404791.0    216424 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.459e-01    0.3819
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                              Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -2.91575    7.13222  -0.409   0.6827    
# log_sl_                       0.13378    0.00789  16.956  < 2e-16 ***
# state_d                       0.45764    0.08040   5.692 1.25e-08 ***
# state_d_sq                   -0.09655    0.04161  -2.320   0.0203 *  
# local_d                       0.10353    0.02332   4.439 9.05e-06 ***
# local_d_sq                   -0.06323    0.01211  -5.221 1.78e-07 ***
# landuse_factorHuman-modified -0.26431    0.04652  -5.682 1.33e-08 ***
# landuse_factorDeciduous       0.28707    0.05380   5.336 9.52e-08 ***
# landuse_factorMixed           0.06510    0.03294   1.977   0.0481 *  
# landuse_factorOpen/shrub/bog  0.05453    0.03915   1.393   0.1637    
# landuse_factorNew forest      0.36780    0.02736  13.443  < 2e-16 ***

#------------------------------------------------------------------season -------------------------------------
# Define GLMM structure without fitting
TMBStruc2 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    minor_d + major_d + local_d + 
    landuse_factor +
    factor(season):minor_d + factor(season):major_d + factor(season):local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2$parameters$theta[1] = log(1e3)  
TMBStruc2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2 <- glmmTMB:::fitTMB(TMBStruc2)
summary(model_glmm2)

#       AIC       BIC    logLik  deviance  df.resid 
#  404843.2  405028.4 -202403.6  404807.2    216418 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.526e-01    0.3906
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.046816   7.132232  -0.427 0.669241    
# log_sl_                       0.133154   0.007888  16.881  < 2e-16 ***
# cos_ta_                       0.005855   0.007516   0.779 0.436027    
# minor_d                       0.311237   0.184335   1.688 0.091329 .  
# major_d                       0.079624   0.197771   0.403 0.687239    
# local_d                       0.151205   0.046947   3.221 0.001278 ** 
# landuse_factorHuman-modified -0.309279   0.046228  -6.690 2.23e-11 ***
# landuse_factorDeciduous       0.290335   0.053794   5.397 6.77e-08 ***
# landuse_factorMixed           0.062718   0.032903   1.906 0.056632 .  
# landuse_factorOpen/shrub/bog  0.056846   0.039208   1.450 0.147100    
# landuse_factorNew forest      0.364025   0.027349  13.310  < 2e-16 ***
# minor_d:factor(season)Summer  0.079874   0.239426   0.334 0.738675    
# minor_d:factor(season)Winter  0.003864   0.235411   0.016 0.986906    
# major_d:factor(season)Summer -0.155393   0.255211  -0.609 0.542604    
# major_d:factor(season)Winter  0.196034   0.250535   0.782 0.433944    
# local_d:factor(season)Summer  0.062014   0.059387   1.044 0.296374    
# local_d:factor(season)Winter -0.195189   0.059315  -3.291 0.000999 ***


# ----------------------------------------------------- season with 2 road categories ---------

TMBStruc2.0 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    state_d + local_d + 
    landuse_factor +
    factor(season):state_d + factor(season):local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.0$parameters$theta[1] = log(1e3)  
TMBStruc2.0$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.0 <- glmmTMB:::fitTMB(TMBStruc2.0)
summary(model_glmm2.0)

#       AIC       BIC    logLik  deviance  df.resid 
#  404826.5  404980.8 -202398.2  404796.5    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.503e-01    0.3877
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.067969   7.132182  -0.430  0.66708    
# log_sl_                       0.133110   0.007887  16.877  < 2e-16 ***
# cos_ta_                       0.005997   0.007516   0.798  0.42490    
# state_d                       0.423348   0.163828   2.584  0.00976 ** 
# local_d                       0.136731   0.046772   2.923  0.00346 ** 
# landuse_factorHuman-modified -0.308427   0.046196  -6.676 2.45e-11 ***
# landuse_factorDeciduous       0.289615   0.053750   5.388 7.12e-08 ***
# landuse_factorMixed           0.066961   0.032909   2.035  0.04188 *  
# landuse_factorOpen/shrub/bog  0.057030   0.039176   1.456  0.14547    
# landuse_factorNew forest      0.367870   0.027357  13.447  < 2e-16 ***
# state_d:factor(season)Summer -0.098771   0.208072  -0.475  0.63500    
# state_d:factor(season)Winter  0.109452   0.209371   0.523  0.60114    
# local_d:factor(season)Summer  0.061553   0.059189   1.040  0.29837    
# local_d:factor(season)Winter -0.194373   0.059262  -3.280  0.00104 ** 

# remove 1 predictor

TMBStruc2.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    state_d + local_d + 
    landuse_factor +
    factor(season):local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.1$parameters$theta[1] = log(1e3)  
TMBStruc2.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.1 <- glmmTMB:::fitTMB(TMBStruc2.1)
summary(model_glmm2.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404823.8  404957.5 -202398.9  404797.8    216423 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.489e-01    0.3859
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.065823   7.132164  -0.430  0.66730    
# log_sl_                       0.133109   0.007887  16.877  < 2e-16 ***
# cos_ta_                       0.005999   0.007516   0.798  0.42475    
# state_d                       0.426067   0.080036   5.323 1.02e-07 ***
# local_d                       0.136548   0.046341   2.947  0.00321 ** 
# landuse_factorHuman-modified -0.309119   0.046190  -6.692 2.20e-11 ***
# landuse_factorDeciduous       0.289584   0.053751   5.388 7.14e-08 ***
# landuse_factorMixed           0.066923   0.032909   2.034  0.04199 *  
# landuse_factorOpen/shrub/bog  0.057267   0.039176   1.462  0.14380    
# landuse_factorNew forest      0.367932   0.027357  13.449  < 2e-16 ***
# local_d:factor(season)Summer  0.058792   0.058643   1.003  0.31608    
# local_d:factor(season)Winter -0.189572   0.058538  -3.238  0.00120 ** 

# remove another predictor
TMBStruc2.2 <- glmmTMB(
  case_ ~ log_sl_ + 
    state_d + local_d + 
    landuse_factor +
    factor(season):local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.2$parameters$theta[1] = log(1e3)  
TMBStruc2.2$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.2 <- glmmTMB:::fitTMB(TMBStruc2.2)
summary(model_glmm2.2)

#       AIC       BIC    logLik  deviance  df.resid 
#  404822.4  404945.8 -202399.2  404798.4    216424 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.461e-01    0.3823
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.064854   7.132101  -0.430  0.66739    
# log_sl_                       0.133211   0.007886  16.891  < 2e-16 ***
# state_d                       0.424884   0.079972   5.313 1.08e-07 ***
# local_d                       0.135887   0.046307   2.934  0.00334 ** 
# landuse_factorHuman-modified -0.307816   0.046149  -6.670 2.56e-11 ***
# landuse_factorDeciduous       0.289763   0.053740   5.392 6.97e-08 ***
# landuse_factorMixed           0.067065   0.032901   2.038  0.04151 *  
# landuse_factorOpen/shrub/bog  0.057642   0.039164   1.472  0.14107    
# landuse_factorNew forest      0.368064   0.027352  13.457  < 2e-16 ***
# local_d:factor(season)Summer  0.058718   0.058609   1.002  0.31641    
# local_d:factor(season)Winter -0.189552   0.058504  -3.240  0.00120 ** 


# changed to summer as reference

steps3$season <- steps3$season %>% relevel(ref = "Winter")


TMBStruc2.0.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    state_d + local_d + 
    landuse_factor +
    season:state_d + season:local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc2.0.1$parameters$theta[1] = log(1e3)  
TMBStruc2.0.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm2.0.1 <- glmmTMB:::fitTMB(TMBStruc2.0.1)
summary(model_glmm2.0.1)


#       AIC       BIC    logLik  deviance  df.resid 
#  404810.6  404964.9 -202390.3  404780.6    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.472e-01    0.3836
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.053675   7.132130  -0.428   0.6685    
# log_sl_                       0.132466   0.007898  16.773  < 2e-16 ***
# cos_ta_                      -0.001384   0.007507  -0.184   0.8537    
# state_d                       0.304266   0.128304   2.371   0.0177 *  
# local_d                       0.186996   0.036415   5.135 2.82e-07 ***
# landuse_factorHuman-modified -0.347723   0.046235  -7.521 5.44e-14 ***
# landuse_factorDeciduous       0.293116   0.053588   5.470 4.50e-08 ***
# landuse_factorMixed           0.048729   0.032922   1.480   0.1388    
# landuse_factorOpen/shrub/bog  0.028992   0.038994   0.744   0.4572    
# landuse_factorNew forest      0.362549   0.027313  13.274  < 2e-16 ***
# state_d:seasonSummerSpring    0.124582   0.207790   0.600   0.5488    
# state_d:seasonSummerWinter    0.140828   0.183673   0.767   0.4432    
# local_d:seasonSummerSpring   -0.050732   0.059318  -0.855   0.3924    
# local_d:seasonSummerWinter   -0.230134   0.051796  -4.443 8.87e-06 ***


#spring as reference


#       AIC       BIC    logLik  deviance  df.resid 
#  404810.6  404964.9 -202390.3  404780.6    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.526e-01    0.3906
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.051341   7.132240  -0.428  0.66878    
# log_sl_                       0.132460   0.007898  16.772  < 2e-16 ***
# cos_ta_                      -0.001383   0.007507  -0.184  0.85383    
# state_d                       0.428794   0.163548   2.622  0.00875 ** 
# local_d                       0.136241   0.046967   2.901  0.00372 ** 
# landuse_factorHuman-modified -0.347719   0.046235  -7.521 5.45e-14 ***
# landuse_factorDeciduous       0.293082   0.053588   5.469 4.52e-08 ***
# landuse_factorMixed           0.048722   0.032922   1.480  0.13889    
# landuse_factorOpen/shrub/bog  0.028999   0.038994   0.744  0.45707    
# landuse_factorNew forest      0.362542   0.027313  13.274  < 2e-16 ***
# state_d:factor(season)Summer -0.124571   0.207791  -0.600  0.54884    
# state_d:factor(season)Winter  0.016286   0.209741   0.078  0.93811    
# local_d:factor(season)Summer  0.050751   0.059318   0.856  0.39223    
# local_d:factor(season)Winter -0.179359   0.059527  -3.013  0.00259 ** 

# winter as reference

#       AIC       BIC    logLik  deviance  df.resid 
#  404810.6  404964.9 -202390.3  404780.6    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.532e-01    0.3914
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.051145   7.132255  -0.428 0.668800    
# log_sl_                       0.132472   0.007898  16.774  < 2e-16 ***
# cos_ta_                      -0.001380   0.007507  -0.184 0.854138    
# state_d                       0.445158   0.131577   3.383 0.000716 ***
# local_d                      -0.043098   0.037036  -1.164 0.244543    
# landuse_factorHuman-modified -0.347697   0.046235  -7.520 5.47e-14 ***
# landuse_factorDeciduous       0.293065   0.053588   5.469 4.53e-08 ***
# landuse_factorMixed           0.048731   0.032922   1.480 0.138822    
# landuse_factorOpen/shrub/bog  0.029019   0.038994   0.744 0.456761    
# landuse_factorNew forest      0.362526   0.027313  13.273  < 2e-16 ***
# state_d:seasonSummer         -0.140878   0.183672  -0.767 0.443078    
# state_d:seasonSpring         -0.016337   0.209740  -0.078 0.937914    
# local_d:seasonSummer          0.230114   0.051795   4.443 8.88e-06 ***
# local_d:seasonSpring          0.179345   0.059527   3.013 0.002588 ** 


# ---------------------------------------------------------- time ------------------------------------------
TMBStruc3 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    minor_d + major_d + local_d + 
    landuse_factor +
    factor(time_category):minor_d + factor(time_category):major_d + factor(time_category):local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc3$parameters$theta[1] = log(1e3)  
TMBStruc3$mapArg = list(theta = factor(c(NA, 1)))
model_glmm3 <- glmmTMB:::fitTMB(TMBStruc3)
summary(model_glmm3)

#       AIC       BIC    logLik  deviance  df.resid 
#  404836.2  405021.3 -202400.1  404800.2    216418 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.564e-01    0.3955
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                        Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                           -3.062966   7.132324  -0.429  0.66760    
# log_sl_                                0.133139   0.007890  16.875  < 2e-16 ***
# cos_ta_                                0.005857   0.007517   0.779  0.43587    
# minor_d                                0.267750   0.130262   2.055  0.03983 *  
# major_d                               -0.124935   0.137596  -0.908  0.36388    
# local_d                                0.203705   0.031879   6.390 1.66e-10 ***
# landuse_factorHuman-modified          -0.310605   0.046250  -6.716 1.87e-11 ***
# landuse_factorDeciduous                0.280788   0.053728   5.226 1.73e-07 ***
# landuse_factorMixed                    0.060371   0.032904   1.835  0.06654 .  
# landuse_factorOpen/shrub/bog           0.049755   0.039173   1.270  0.20404    
# landuse_factorNew forest               0.362758   0.027345  13.266  < 2e-16 ***
# minor_d:factor(time_category)Twilight -0.115319   0.286634  -0.402  0.68745    
# minor_d:factor(time_category)Night     0.199802   0.197350   1.012  0.31133    
# major_d:factor(time_category)Twilight  0.162641   0.301926   0.539  0.59011    
# major_d:factor(time_category)Night     0.541871   0.208737   2.596  0.00943 ** 
# local_d:factor(time_category)Twilight -0.078529   0.069740  -1.126  0.26016    
# local_d:factor(time_category)Night    -0.256806   0.049152  -5.225 1.74e-07 ***


# ---------------------------------------------------- time of day but 2 road classes ----------


TMBStruc3.0 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    state_d + local_d + 
    landuse_factor +
    factor(time_category):state_d + factor(time_category):local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc3.0$parameters$theta[1] = log(1e3)  
TMBStruc3.0$mapArg = list(theta = factor(c(NA, 1)))
model_glmm3.0 <- glmmTMB:::fitTMB(TMBStruc3.0)
summary(model_glmm3.0)


#       AIC       BIC    logLik  deviance  df.resid 
#  404820.4  404974.6 -202395.2  404790.4    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance Std.Dev.
#  str_ID (Intercept) 1.00e+06 1000.000
#  id     (Intercept) 1.49e-01    0.386
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                        Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                           -3.070516   7.132167  -0.431  0.66682    
# log_sl_                                0.133197   0.007889  16.884  < 2e-16 ***
# cos_ta_                                0.005970   0.007516   0.794  0.42702    
# state_d                                0.302483   0.113566   2.663  0.00773 ** 
# local_d                                0.187768   0.031807   5.903 3.56e-09 ***
# landuse_factorHuman-modified          -0.309879   0.046231  -6.703 2.04e-11 ***
# landuse_factorDeciduous                0.281217   0.053704   5.236 1.64e-07 ***
# landuse_factorMixed                    0.064956   0.032910   1.974  0.04841 *  
# landuse_factorOpen/shrub/bog           0.051354   0.039143   1.312  0.18953    
# landuse_factorNew forest               0.366602   0.027352  13.403  < 2e-16 ***
# state_d:factor(time_category)Night     0.399247   0.173414   2.302  0.02132 *  
# state_d:factor(time_category)Twilight -0.204400   0.246845  -0.828  0.40764    
# local_d:factor(time_category)Night    -0.257392   0.049233  -5.228 1.71e-07 ***
# local_d:factor(time_category)Twilight -0.065602   0.069578  -0.943  0.34575    

#remove 1 predictor

TMBStruc3.0.1 <- glmmTMB(
  case_ ~ log_sl_ +
    state_d + local_d + 
    landuse_factor +
    factor(time_category):state_d + factor(time_category):local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc3.0.1$parameters$theta[1] = log(1e3)  
TMBStruc3.0.1$mapArg = list(theta = factor(c(NA, 1)))
model_glmm3.0.1 <- glmmTMB:::fitTMB(TMBStruc3.0.1)
summary(model_glmm3.0.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404819.0  404963.0 -202395.5  404791.0    216422 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.511e-01    0.3888
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                        Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                           -3.074765   7.132204  -0.431  0.66639    
# log_sl_                                0.133297   0.007888  16.898  < 2e-16 ***
# state_d                                0.301562   0.113489   2.657  0.00788 ** 
# local_d                                0.187086   0.031777   5.887 3.92e-09 ***
# landuse_factorHuman-modified          -0.308613   0.046190  -6.681 2.37e-11 ***
# landuse_factorDeciduous                0.281376   0.053693   5.240 1.60e-07 ***
# landuse_factorMixed                    0.065066   0.032903   1.978  0.04798 *  
# landuse_factorOpen/shrub/bog           0.051692   0.039131   1.321  0.18649    
# landuse_factorNew forest               0.366709   0.027347  13.409  < 2e-16 ***
# state_d:factor(time_category)Night     0.398401   0.173304   2.299  0.02151 *  
# state_d:factor(time_category)Twilight -0.203898   0.246682  -0.827  0.40849    
# local_d:factor(time_category)Night    -0.257407   0.049205  -5.231 1.68e-07 ***
# local_d:factor(time_category)Twilight -0.065529   0.069543  -0.942  0.34605    

# ----------------------------------------- time of day but in two categories ----------------------


steps3.1 <- steps3 %>% 
  mutate(
    time_category3.1 = 
      case_when(
        time_category == "Night" | time_category == "Twilight" ~ "Dark", 
        TRUE ~ "Day"
    )
  )


steps3.1$time_category3.1 <- factor(steps3.1$time_category3.1) %>% relevel(ref = "Day")



TMBStruc3.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    minor_d + major_d + local_d + 
    landuse_factor +
    time_category3.1:minor_d + time_category3.1:major_d + time_category3.1:local_d +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3.1,
  doFit = FALSE
)

TMBStruc3.1$parameters$theta[1] = log(1e3)  

TMBStruc3.1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm3.1 <- glmmTMB:::fitTMB(TMBStruc3.1)

summary(model_glmm3.1)

#       AIC       BIC    logLik  deviance  df.resid 
#  404839.1  404993.4 -202404.5  404809.1    216421 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev.
#  str_ID (Intercept) 1.000e+06 1000.000
#  id     (Intercept) 1.537e-01    0.392
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -3.066524   7.132260  -0.430   0.6672    
# log_sl_                       0.133145   0.007889  16.878  < 2e-16 ***
# cos_ta_                       0.005872   0.007516   0.781   0.4347    
# minor_d                       0.267968   0.130261   2.057   0.0397 *  
# major_d                      -0.124804   0.137594  -0.907   0.3644    
# local_d                       0.203761   0.031878   6.392 1.64e-10 ***
# landuse_factorHuman-modified -0.309251   0.046222  -6.691 2.22e-11 ***
# landuse_factorDeciduous       0.281079   0.053741   5.230 1.69e-07 ***
# landuse_factorMixed           0.060394   0.032900   1.836   0.0664 .  
# landuse_factorOpen/shrub/bog  0.049524   0.039173   1.264   0.2061    
# landuse_factorNew forest      0.362787   0.027344  13.267  < 2e-16 ***
# minor_d:time_category3.1Dark  0.110346   0.182739   0.604   0.5459    
# major_d:time_category3.1Dark  0.442162   0.193096   2.290   0.0220 *  
# local_d:time_category3.1Dark -0.208665   0.045187  -4.618 3.88e-06 ***







```

# ---------------------------- OTHER MODELS -------------------------------------------------------


```{r other models}


# -------------------------------------------------- models without scaling ----------------

steps3_original$major_d <- steps3_original$major_d + 0.01
steps3_original$minor_d <- steps3_original$minor_d + 0.01
steps3_original$local_d <- steps3_original$local_d + 0.01
steps3_original$state_d <- steps3_original$state_d + 0.01



summary(steps3_original$state_d)


TMBStruc_unscaled <- glmmTMB(
  case_ ~ log(sl_) + cos(ta_) + 
    log(major_d) + log(minor_d) + log(local_d) + 
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3_original,
  doFit = FALSE
)

TMBStruc_unscaled$parameters$theta[1] = log(1e3)  
TMBStruc_unscaled$mapArg = list(theta = factor(c(NA, 1)))

model_glmm_unscaled <- glmmTMB:::fitTMB(TMBStruc_unscaled)

summary(model_glmm_unscaled)

#       AIC       BIC    logLik  deviance  df.resid 
#  364213.0  364335.1 -182094.5  364189.0    194809 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 1.767e-03 4.203e-02
# Number of obs: 194821, groups:  str_ID, 17711; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -8.719916   7.538580  -1.157   0.2474    
# log(sl_)                      0.145907   0.007935  18.388  < 2e-16 ***
# cos(ta_)                      0.005925   0.012773   0.464   0.6427    
# log(major_d)                  0.379797   0.055793   6.807 9.95e-12 ***
# log(minor_d)                  0.259076   0.062244   4.162 3.15e-05 ***
# log(local_d)                  0.027645   0.006793   4.070 4.71e-05 ***
# landuse_factorHuman-modified -0.227838   0.048165  -4.730 2.24e-06 ***
# landuse_factorDeciduous       0.311899   0.056685   5.502 3.75e-08 ***
# landuse_factorMixed           0.084171   0.034586   2.434   0.0149 *  
# landuse_factorOpen/shrub/bog  0.084088   0.040905   2.056   0.0398 *  
# landuse_factorNew forest      0.418621   0.028681  14.596  < 2e-16 ***



TMBStruc_unscaled1 <- glmmTMB(
  case_ ~ log(sl_) + cos(ta_) + 
    log(minor_d) + log(major_d) + log(local_d) + 
    landuse_factor +
    factor(time_category):log(minor_d) + factor(time_category):log(major_d) + factor(time_category):log(local_d) +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3_original,
  doFit = FALSE
)

TMBStruc_unscaled1$parameters$theta[1] = log(1e3)  
TMBStruc_unscaled1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm_unscaled1 <- glmmTMB:::fitTMB(TMBStruc_unscaled1)

summary(model_glmm_unscaled1)

#       AIC       BIC    logLik  deviance  df.resid 
#  364188.9  364372.1 -182076.4  364152.9    194803 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1.000e+03
#  id     (Intercept) 1.614e-03 4.018e-02
# Number of obs: 194821, groups:  str_ID, 17711; id, 8
# 
# Conditional model:
#                                             Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                -8.827107   7.539078  -1.171  0.24166    
# log(sl_)                                    0.147558   0.007945  18.572  < 2e-16 ***
# cos(ta_)                                    0.006080   0.012775   0.476  0.63410    
# log(minor_d)                                0.279987   0.097728   2.865  0.00417 ** 
# log(major_d)                                0.395830   0.088305   4.483 7.38e-06 ***
# log(local_d)                                0.075505   0.012896   5.855 4.78e-09 ***
# landuse_factorHuman-modified               -0.230817   0.048274  -4.781 1.74e-06 ***
# landuse_factorDeciduous                     0.314534   0.056701   5.547 2.90e-08 ***
# landuse_factorMixed                         0.086503   0.034602   2.500  0.01242 *  
# landuse_factorOpen/shrub/bog                0.087503   0.040917   2.139  0.03247 *  
# landuse_factorNew forest                    0.420556   0.028692  14.657  < 2e-16 ***
# log(minor_d):factor(time_category)Night    -0.026954   0.131876  -0.204  0.83805    
# log(minor_d):factor(time_category)Twilight -0.050252   0.208371  -0.241  0.80943    
# log(major_d):factor(time_category)Night     0.023361   0.121961   0.192  0.84810    
# log(major_d):factor(time_category)Twilight -0.216888   0.150383  -1.442  0.14924    
# log(local_d):factor(time_category)Night    -0.082118   0.015481  -5.304 1.13e-07 ***
# log(local_d):factor(time_category)Twilight -0.008528   0.025553  -0.334  0.73858    






TMBStruc_unscaled2 <- glmmTMB(
  case_ ~ log(sl_) + cos(ta_) + 
    log(state_d) + log(local_d) + 
    landuse_factor +
    factor(time_category):log(state_d)+ factor(time_category):log(local_d) +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3_original,
  doFit = FALSE
)

TMBStruc_unscaled2$parameters$theta[1] = log(1e3)  
TMBStruc_unscaled2$mapArg = list(theta = factor(c(NA, 1)))

model_glmm_unscaled2 <- glmmTMB:::fitTMB(TMBStruc_unscaled2)

summary(model_glmm_unscaled2)


#       AIC       BIC    logLik  deviance  df.resid 
#  364183.9  364336.5 -182076.9  364153.9    194806 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 2.011e-01    0.4485
# Number of obs: 194821, groups:  str_ID, 17711; id, 8
# 
# Conditional model:
#                                             Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                -6.686061   7.525441  -0.888   0.3743    
# log(sl_)                                    0.148102   0.007945  18.641  < 2e-16 ***
# cos(ta_)                                    0.006089   0.012775   0.477   0.6336    
# log(state_d)                                0.425310   0.072090   5.900 3.64e-09 ***
# log(local_d)                                0.075346   0.012886   5.847 4.99e-09 ***
# landuse_factorHuman-modified               -0.232844   0.048198  -4.831 1.36e-06 ***
# landuse_factorDeciduous                     0.314852   0.056677   5.555 2.77e-08 ***
# landuse_factorMixed                         0.085999   0.034601   2.485   0.0129 *  
# landuse_factorOpen/shrub/bog                0.089886   0.040903   2.198   0.0280 *  
# landuse_factorNew forest                    0.420756   0.028691  14.665  < 2e-16 ***
# log(state_d):factor(time_category)Night    -0.067921   0.096952  -0.701   0.4836    
# log(state_d):factor(time_category)Twilight -0.204533   0.131558  -1.555   0.1200    
# log(local_d):factor(time_category)Night    -0.081835   0.015474  -5.289 1.23e-07 ***
# log(local_d):factor(time_category)Twilight -0.008628   0.025537  -0.338   0.7355 

# remove 1 nonsignificant predictor

TMBStruc_unscaled2.1 <- glmmTMB(
  case_ ~ log(sl_) +
    log(state_d) + log(local_d) + 
    landuse_factor +
    factor(time_category):log(state_d)+ factor(time_category):log(local_d) +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3_original,
  doFit = FALSE
)

TMBStruc_unscaled2.1$parameters$theta[1] = log(1e3)  
TMBStruc_unscaled2.1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm_unscaled2.1 <- glmmTMB:::fitTMB(TMBStruc_unscaled2.1)

summary(model_glmm_unscaled2.1)


#       AIC       BIC    logLik  deviance  df.resid 
#  364182.1  364324.6 -182077.0  364154.1    194807 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 2.008e-01    0.4481
# Number of obs: 194821, groups:  str_ID, 17711; id, 8
# 
# Conditional model:
#                                             Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                -6.678994   7.525403  -0.888   0.3748    
# log(sl_)                                    0.148160   0.007944  18.650  < 2e-16 ***
# log(state_d)                                0.424478   0.072023   5.894 3.78e-09 ***
# log(local_d)                                0.075221   0.012879   5.841 5.20e-09 ***
# landuse_factorHuman-modified               -0.232042   0.048161  -4.818 1.45e-06 ***
# landuse_factorDeciduous                     0.314903   0.056668   5.557 2.74e-08 ***
# landuse_factorMixed                         0.086003   0.034595   2.486   0.0129 *  
# landuse_factorOpen/shrub/bog                0.089969   0.040896   2.200   0.0278 *  
# landuse_factorNew forest                    0.420815   0.028688  14.669  < 2e-16 ***
# log(state_d):factor(time_category)Night    -0.068000   0.096868  -0.702   0.4827    
# log(state_d):factor(time_category)Twilight -0.203967   0.131476  -1.551   0.1208    
# log(local_d):factor(time_category)Night    -0.081794   0.015470  -5.287 1.24e-07 ***
# log(local_d):factor(time_category)Twilight -0.008597   0.025529  -0.337   0.7363  







# Visualization
ggplot(steps3_original %>% filter(case_ == TRUE), 
       aes(x = time_category, y = major_d)) +
  geom_boxplot() +
  labs(title = "Actual distances to major roads by time of day",
       y = "Distance (m)")

ggplot(steps3_original %>% filter(case_ == TRUE), 
       aes(x = time_category, y = minor_d)) +
  geom_boxplot() +
  labs(title = "Actual distances to minor roads by time of day",
       y = "Distance (m)")

ggplot(steps3_original %>% filter(case_ == TRUE), 
       aes(x = time_category, y = local_d)) +
  geom_boxplot() +
  labs(title = "Actual distances to local roads by time of day",
       y = "Distance (m)")


ggplot(steps3_original %>% filter(case_ == TRUE), 
       aes(x = time_category, y = state_d)) +
  geom_boxplot() +
  labs(title = "Actual distances to state roads by time of day",
       y = "Distance (m)")

# Alternative approach using data.frame subsets
day_summary <- with(subset(steps3_original, case_ == TRUE & time_category == "Day"), 
                  c(major_mean = mean(major_d, na.rm = TRUE),
                    major_median = median(major_d, na.rm = TRUE),
                    minor_mean = mean(minor_d, na.rm = TRUE),
                    local_mean = mean(local_d, na.rm = TRUE),
                    n = length(major_d)))

night_summary <- with(subset(steps3_original, case_ == TRUE & time_category == "Night"), 
                     c(major_mean = mean(major_d, na.rm = TRUE),
                       major_median = median(major_d, na.rm = TRUE),
                       minor_mean = mean(minor_d, na.rm = TRUE),
                       local_mean = mean(local_d, na.rm = TRUE),
                       n = length(major_d)))

twilight_summary <- with(subset(steps3_original, case_ == TRUE & time_category == "Twilight"), 
                        c(major_mean = mean(major_d, na.rm = TRUE),
                          major_median = median(major_d, na.rm = TRUE),
                          minor_mean = mean(minor_d, na.rm = TRUE),
                          local_mean = mean(local_d, na.rm = TRUE),
                          n = length(major_d)))

# Combine results
rbind(Day = day_summary, Night = night_summary, Twilight = twilight_summary)
#------------------------------------------------- making road crossing detection -----------------------

steps3$row_id <- 1:nrow(steps3)

steps_lines <- st_sf(
  geometry = mapply(
    function(x1, y1, x2, y2) {
      st_linestring(matrix(c(x1, y1, x2, y2), ncol = 2, byrow = TRUE))
    },
    steps3$x1_, steps3$y1_, steps3$x2_, steps3$y2_,
    SIMPLIFY = FALSE
  ),
  row_id = steps3$row_id,
  step_id_ = steps3$step_id_,
  case_ = steps3$case_,
  crs = 3301
) 


# data frame with crossing information
crossing_data <- data.frame(
  row_id = steps_lines$row_id,
  crosses_major = lengths(st_intersects(steps_lines, roads[roads$class >= 2, ])) > 0,
  crosses_minor = lengths(st_intersects(steps_lines, roads[roads$class == 1, ])) > 0,
  crosses_local = lengths(st_intersects(steps_lines, roads[roads$class == 0, ])) > 0
)

#crossing information back to steps3
steps3 <- merge(steps3, crossing_data, by = "row_id", all.x = TRUE)
steps3$crosses_state <- steps3$crosses_major | steps3$crosses_minor

table(steps3$crosses_major)
table(steps3$crosses_minor)
table(steps3$crosses_local)


# -------------------------------------------------------------------- crossing  -------------

# Define GLMM structure without fitting
TMBStruc22 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc22$parameters$theta[1] = log(1e3)  

TMBStruc22$mapArg = list(theta = factor(c(NA, 1)))

model_glmm22 <- glmmTMB:::fitTMB(TMBStruc22)

summary(model_glmm22)

#       AIC       BIC    logLik  deviance  df.resid 
#  364523.2  364635.2 -182250.6  364501.2    194810 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.528e-01    0.3909
# Number of obs: 194821, groups:  str_ID, 17711; id, 8
# 
# Conditional model:
#                               Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                  -2.889117   7.517020  -0.384   0.7007    
# log_sl_                       0.152736   0.008532  17.902  < 2e-16 ***
# cos_ta_                       0.009919   0.007932   1.251   0.2111    
# crosses_minorTRUE             0.430581   0.217417   1.980   0.0477 *  
# crosses_majorTRUE            -1.064889   0.244930  -4.348 1.38e-05 ***
# crosses_localTRUE            -0.396981   0.045602  -8.705  < 2e-16 ***
# landuse_factorHuman-modified -0.497643   0.048607 -10.238  < 2e-16 ***
# landuse_factorDeciduous       0.235597   0.058366   4.037 5.42e-05 ***
# landuse_factorMixed          -0.029234   0.036510  -0.801   0.4233    
# landuse_factorOpen/shrub/bog -0.039269   0.040255  -0.976   0.3293  


# ---- crossing with landuse interaction -----

# Model for major roads only 
TMBStruc_major <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_major + landuse_factor + landuse_factor:crosses_major +
    (1 | str_ID) + (1 | id), 
  family = poisson, data = steps3, doFit = FALSE
)
TMBStruc_major$parameters$theta[1] = log(1e3)  
TMBStruc_major$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_major <- glmmTMB:::fitTMB(TMBStruc_major)
summary(model_glmm_major)

# Model for minor roads only
TMBStruc_minor <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + landuse_factor + landuse_factor:crosses_minor +
    (1 | str_ID) + (1 | id), 
  family = poisson, data = steps3, doFit = FALSE
)
TMBStruc_minor$parameters$theta[1] = log(1e3)  
TMBStruc_minor$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_minor <- glmmTMB:::fitTMB(TMBStruc_minor)
summary(model_glmm_minor)

# Model for local roads only
TMBStruc_local <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_local + landuse_factor + landuse_factor:crosses_local +
    (1 | str_ID) + (1 | id), 
  family = poisson, data = steps3, doFit = FALSE
)
TMBStruc_local$parameters$theta[1] = log(1e3)  
TMBStruc_local$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_local <- glmmTMB:::fitTMB(TMBStruc_local)
summary(model_glmm_local)

# Model for state roads only (major + minor)
TMBStruc_state <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_state + landuse_factor + landuse_factor:crosses_state +
    (1 | str_ID) + (1 | id), 
  family = poisson, data = steps3, doFit = FALSE
)
TMBStruc_state$parameters$theta[1] = log(1e3)  
TMBStruc_state$mapArg = list(theta = factor(c(NA, 1)))
model_glmm_state <- glmmTMB:::fitTMB(TMBStruc_state)
summary(model_glmm_state)


#------------------------------------------------------------------season 2: with crossing --------------------------
# Define GLMM structure without fitting
TMBStruc33 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    factor(season):crosses_minor + factor(season):crosses_major + factor(season):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc33$parameters$theta[1] = log(1e3)  

TMBStruc33$mapArg = list(theta = factor(c(NA, 1)))

model_glmm33 <- glmmTMB:::fitTMB(TMBStruc33)

summary(model_glmm33)

#       AIC       BIC    logLik  deviance  df.resid 
#  364519.3  364712.7 -182240.6  364481.3    194802 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.852e-01    0.4303
# Number of obs: 194821, groups:  str_ID, 17711; id, 8
# 
# Conditional model:
#                                          Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                             -2.805462  12.928231  -0.217 0.828206    
# log_sl_                                  0.152628   0.008531  17.890  < 2e-16 ***
# cos_ta_                                  0.010191   0.007933   1.285 0.198949    
# crosses_minorTRUE                        0.552465   0.319454   1.729 0.083737 .  
# crosses_majorTRUE                       -0.595107   0.358432  -1.660 0.096853 .  
# crosses_localTRUE                       -0.276450   0.077844  -3.551 0.000383 ***
# landuse_factorHuman-modified            -0.499699   0.048623 -10.277  < 2e-16 ***
# landuse_factorDeciduous                  0.233602   0.058356   4.003 6.25e-05 ***
# landuse_factorMixed                     -0.030514   0.036512  -0.836 0.403316    
# landuse_factorOpen/shrub/bog            -0.041978   0.040286  -1.042 0.297416    
# crosses_minorFALSE:factor(season)Summer  0.115324  17.845459   0.006 0.994844    
# crosses_minorTRUE:factor(season)Summer  -1.353534  17.863601  -0.076 0.939602    
# crosses_minorFALSE:factor(season)Winter -0.474857  19.036783  -0.025 0.980099    
# crosses_minorTRUE:factor(season)Winter  -0.203714  19.042630  -0.011 0.991465    
# crosses_majorTRUE:factor(season)Summer  -0.176694   0.543362  -0.325 0.745040    
# crosses_majorTRUE:factor(season)Winter  -1.533119   0.697401  -2.198 0.027925 *  
# crosses_localTRUE:factor(season)Summer  -0.090096   0.105826  -0.851 0.394569    
# crosses_localTRUE:factor(season)Winter  -0.298422   0.114455  -2.607 0.009125 ** 

# ---------------------------------------------------------- time 2: with crossings -----------------------
TMBStruc44 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    factor(time_category):crosses_minor + factor(time_category):crosses_major + factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc44$parameters$theta[1] = log(1e3)  

TMBStruc44$mapArg = list(theta = factor(c(NA, 1)))

model_glmm44 <- glmmTMB:::fitTMB(TMBStruc44)

summary(model_glmm44)

#       AIC       BIC    logLik  deviance  df.resid 
#  364525.7  364719.1 -182243.9  364487.7    194802 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance Std.Dev.
#  str_ID (Intercept) 1.00e+06 1000.000
#  id     (Intercept) 1.73e-01    0.416
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.493584  10.776294  -0.231   0.8170    
# log_sl_                                           0.152652   0.008533  17.890  < 2e-16 ***
# cos_ta_                                           0.009900   0.007932   1.248   0.2120    
# crosses_minorTRUE                                -0.052670   0.419994  -0.125   0.9002    
# crosses_majorTRUE                                -1.841373   0.589824  -3.122   0.0018 ** 
# crosses_localTRUE                                -0.408808   0.074578  -5.482 4.22e-08 ***
# landuse_factorHuman-modified                     -0.498646   0.048632 -10.254  < 2e-16 ***
# landuse_factorDeciduous                           0.234875   0.058379   4.023 5.74e-05 ***
# landuse_factorMixed                              -0.029332   0.036517  -0.803   0.4218    
# landuse_factorOpen/shrub/bog                     -0.038921   0.040264  -0.967   0.3337    
# crosses_minorFALSE:factor(time_category)Night    -0.739037  16.215502  -0.046   0.9636    
# crosses_minorTRUE:factor(time_category)Night     -0.132759  16.223472  -0.008   0.9935    
# crosses_minorFALSE:factor(time_category)Twilight -0.732099  23.523036  -0.031   0.9752    
# crosses_minorTRUE:factor(time_category)Twilight   0.465979  23.535007   0.020   0.9842    
# crosses_majorTRUE:factor(time_category)Night      0.923753   0.668422   1.382   0.1670    
# crosses_majorTRUE:factor(time_category)Twilight   1.474727   0.814244   1.811   0.0701 .  
# crosses_localTRUE:factor(time_category)Night     -0.050600   0.097499  -0.519   0.6038    
# crosses_localTRUE:factor(time_category)Twilight   0.296533   0.141770   2.092   0.0365 *  



TMBStruc44.1 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    factor(time_category):crosses_major + factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc44.1$parameters$theta[1] = log(1e3)  

TMBStruc44.1$mapArg = list(theta = factor(c(NA, 1)))

model_glmm44.1 <- glmmTMB:::fitTMB(TMBStruc44.1)

summary(model_glmm44.1)


#       AIC       BIC    logLik  deviance  df.resid 
#  404797.2  404982.3 -202380.6  404761.2    216418 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev. 
#  str_ID (Intercept) 1.000e+06 1000.0000
#  id     (Intercept) 1.768e-01    0.4205
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.581427  10.143135  -0.254  0.79911    
# log_sl_                                           0.145857   0.008074  18.064  < 2e-16 ***
# cos_ta_                                           0.006827   0.007516   0.908  0.36377    
# crosses_minorTRUE                                 0.454830   0.213478   2.131  0.03312 *  
# crosses_majorTRUE                                -1.811236   0.589111  -3.075  0.00211 ** 
# crosses_localTRUE                                -0.366286   0.073226  -5.002 5.67e-07 ***
# landuse_factorHuman-modified                     -0.323569   0.045819  -7.062 1.64e-12 ***
# landuse_factorDeciduous                           0.280108   0.053764   5.210 1.89e-07 ***
# landuse_factorMixed                               0.055612   0.032873   1.692  0.09070 .  
# landuse_factorOpen/shrub/bog                      0.051683   0.039172   1.319  0.18705    
# landuse_factorNew forest                          0.357185   0.027352  13.059  < 2e-16 ***
# crosses_majorFALSE:factor(time_category)Night    -0.860312  15.372811  -0.056  0.95537    
# crosses_majorTRUE:factor(time_category)Night     -0.017470  15.387240  -0.001  0.99909    
# crosses_majorFALSE:factor(time_category)Twilight -0.885312  22.568467  -0.039  0.96871    
# crosses_majorTRUE:factor(time_category)Twilight   0.629273  22.582900   0.028  0.97777    
# crosses_localTRUE:factor(time_category)Night     -0.046948   0.095248  -0.493  0.62208    
# crosses_localTRUE:factor(time_category)Twilight   0.348967   0.139523   2.501  0.01238 *  



TMBStruc44.2 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_minor + crosses_major + crosses_local + 
    landuse_factor +
    factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc44.2$parameters$theta[1] = log(1e3)  

TMBStruc44.2$mapArg = list(theta = factor(c(NA, 1)))

model_glmm44.2 <- glmmTMB:::fitTMB(TMBStruc44.2)

summary(model_glmm44.2)


#       AIC       BIC    logLik  deviance  df.resid 
#  404796.9  404961.5 -202382.5  404764.9    216420 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance  Std.Dev.
#  str_ID (Intercept) 1.000e+06 1000.000
#  id     (Intercept) 1.772e-01    0.421
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.794748  10.143083  -0.276   0.7829    
# log_sl_                                           0.145873   0.008074  18.066  < 2e-16 ***
# cos_ta_                                           0.006888   0.007516   0.916   0.3594    
# crosses_minorTRUE                                 0.456420   0.213455   2.138   0.0325 *  
# crosses_majorTRUE                                -1.075378   0.243580  -4.415 1.01e-05 ***
# crosses_localTRUE                                -0.370653   0.073157  -5.067 4.05e-07 ***
# landuse_factorHuman-modified                     -0.323886   0.045812  -7.070 1.55e-12 ***
# landuse_factorDeciduous                           0.280445   0.053763   5.216 1.82e-07 ***
# landuse_factorMixed                               0.055532   0.032873   1.689   0.0912 .  
# landuse_factorOpen/shrub/bog                      0.051238   0.039171   1.308   0.1909    
# landuse_factorNew forest                          0.357247   0.027353  13.061  < 2e-16 ***
# crosses_localFALSE:factor(time_category)Night    -0.502129  15.372757  -0.033   0.9739    
# crosses_localTRUE:factor(time_category)Night     -0.544434  15.373030  -0.035   0.9717    
# crosses_localFALSE:factor(time_category)Twilight -0.344569  22.568425  -0.015   0.9878    
# crosses_localTRUE:factor(time_category)Twilight   0.013748  22.568822   0.001   0.9995 

# -------------------------------------------------------------- crosses time with 2 road -------------------------

TMBStruc55 <- glmmTMB(
  case_ ~ log_sl_ + cos_ta_ + 
    crosses_state+ crosses_local + 
    landuse_factor +
    factor(time_category):crosses_state + factor(time_category):crosses_local +
    (1 | str_ID) +   
    (1 | id), 
  family = poisson,
  data = steps3,
  doFit = FALSE
)

TMBStruc55$parameters$theta[1] = log(1e3)  

TMBStruc55$mapArg = list(theta = factor(c(NA, 1)))

model_glmm55 <- glmmTMB:::fitTMB(TMBStruc55)

summary(model_glmm55)


#       AIC       BIC    logLik  deviance  df.resid 
#  404814.5  404989.3 -202390.2  404780.5    216419 
# 
# Random effects:
# 
# Conditional model:
#  Groups Name        Variance Std.Dev. 
#  str_ID (Intercept) 1.00e+06 1000.0000
#  id     (Intercept) 1.74e-01    0.4171
# Number of obs: 216436, groups:  str_ID, 19676; id, 8
# 
# Conditional model:
#                                                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                                      -2.617208  10.143089  -0.258  0.79638    
# log_sl_                                           0.146005   0.008075  18.082  < 2e-16 ***
# cos_ta_                                           0.006794   0.007516   0.904  0.36600    
# crosses_stateTRUE                                -0.983236   0.331830  -2.963  0.00305 ** 
# crosses_localTRUE                                -0.367865   0.073207  -5.025 5.04e-07 ***
# landuse_factorHuman-modified                     -0.319961   0.045802  -6.986 2.83e-12 ***
# landuse_factorDeciduous                           0.277893   0.053718   5.173 2.30e-07 ***
# landuse_factorMixed                               0.056143   0.032869   1.708  0.08762 .  
# landuse_factorOpen/shrub/bog                      0.053000   0.039172   1.353  0.17605    
# landuse_factorNew forest                          0.358126   0.027347  13.096  < 2e-16 ***
# crosses_stateFALSE:factor(time_category)Night    -0.788127  15.372811  -0.051  0.95911    
# crosses_stateTRUE:factor(time_category)Night     -0.112663  15.377747  -0.007  0.99415    
# crosses_stateFALSE:factor(time_category)Twilight -0.784587  22.568458  -0.035  0.97227    
# crosses_stateTRUE:factor(time_category)Twilight   0.517331  22.574208   0.023  0.98172    
# crosses_localTRUE:factor(time_category)Night     -0.046512   0.095223  -0.488  0.62523    
# crosses_localTRUE:factor(time_category)Twilight   0.344776   0.139541   2.471  0.01348 *  

```
# ----------------------------------------------- VISUALISATIONS ------------------------------------


```{r inspect variables}



numeric_predictors <- steps3 %>% select(-"x1_", -"x2_", -"y1_", -"y2_", "burst_", "step_id_")

correlation_matrix <- cor(numeric_predictors, use = "complete.obs")

print(correlation_matrix)

corrplot(correlation_matrix, method = "color", type = "upper", 
         order = "hclust", tl.col = "black", tl.srt = 45,
         diag = FALSE) 



library(polycor)


steps3$crosses_major <- as.factor(steps3$crosses_major)
steps3$crosses_minor <- as.factor(steps3$crosses_minor)
steps3$crosses_local <- as.factor(steps3$crosses_local)
steps3$time_category <- as.factor(steps3$time_category)
steps3$season <- as.factor(steps3$season)

vars_of_interest <- steps3[, c("landuse_factor", "major_d", "minor_d", "local_d", 
                               "time_category", "season", 
                               "crosses_major", "crosses_minor", "crosses_local")]


het_cor <- hetcor(vars_of_interest)
het_cor$correlations
corrplot(het_cor$correlations, method = "color", 
         type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)


ggplot(steps3_unscaled, aes(x = major_d_orig, fill = factor(case_))) + 
  geom_histogram(bins = 30, alpha = 0.5, position = "identity") +
  scale_fill_manual(values = c("red", "blue"), labels = c("Available", "Used")) +
  labs(title = "Histogram of Distance to Major Roads",
       x = "Distance to Major Roads (m)",
       y = "Count",
       fill = "Step Type") +
  theme_minimal()

ggplot(steps3_unscaled, aes(x = local_d_orig, fill = factor(case_))) + 
  geom_histogram(bins = 30, alpha = 0.5, position = "identity") +
  scale_fill_manual(values = c("red", "blue"), labels = c("Available", "Used")) +
  labs(title = "Histogram of Distance to Local Roads",
       x = "Distance to Local Roads (m)",
       y = "Count",
       fill = "Step Type") +
  theme_minimal()

# --------------------------------------- visualisations -------------------------------------------------------------------

# Function to create RSS plots for model_glmm3.0.1
# Corrected function to create RSS plots for model_glmm3.0.1
plot_time_rss <- function(model, data, road_type = "state", 
                          max_dist = 2000, n_points = 200) {
  
  # Get scaling parameters
  if(road_type == "state") {
    var_name <- "state_d"
    var_center <- attr(data$state_d, "scaled:center")
    var_scale <- attr(data$state_d, "scaled:scale")
  } else {
    var_name <- "local_d"
    var_center <- attr(data$local_d, "scaled:center")
    var_scale <- attr(data$local_d, "scaled:scale")
  }
  
  # Extract fixed effect coefficients
  coefs <- fixef(model)$cond
  
  # Get main coefficient
  main_coef_name <- var_name
  main_coef <- coefs[main_coef_name]
  
  # Create sequence of original distance values
  original_seq <- seq(0, max_dist, length.out = n_points)
  
  # Create dataframe to store results
  results <- data.frame()
  
  # For each time category
  for(time_cat in c("Day", "Night", "Twilight")) {
    
    # Create scaled distance sequence
    scaled_seq <- (original_seq - var_center) / var_scale
    
    # Calculate effect size for this time category
    if(time_cat == "Day") {
      # Day is reference category, so just use main effect
      effect_size <- main_coef
    } else {
      # For Night and Twilight, find the interaction term
      interaction_name <- paste0(var_name, ":factor(time_category)", time_cat)
      
      # Check if interaction exists in model
      if(interaction_name %in% names(coefs)) {
        effect_size <- main_coef + coefs[interaction_name]
      } else {
        effect_size <- main_coef
      }
    }
    
    # Calculate linear predictor for the specific road effect
    linear_pred <- scaled_seq * effect_size
    
    # Convert to relative selection strength
    rss <- exp(linear_pred)
    
    # Add to results dataframe
    cat_results <- data.frame(
      distance = original_seq,
      time_category = time_cat,
      scaled_dist = scaled_seq,
      linear_pred = linear_pred,
      rss = rss
    )
    
    # Add to results dataframe
    results <- rbind(results, cat_results)
  }
  
  # Scale RSS to be relative to minimum value (minimum = 1)
  results$rss_relative <- results$rss / min(results$rss)
  
  # Create plot
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  
  p <- ggplot(results, aes(x = distance, y = rss_relative, color = time_category)) +
    geom_line(linewidth = 1.2) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Relative Selection Strength",
         title = paste0("Moose Selection Relative to Distance from ", road_label),
         subtitle = "By time of day",
         color = "Time of Day") +
    theme_minimal() +
    theme(legend.position = "bottom",
          panel.grid.minor = element_blank(),
          panel.border = element_rect(fill = NA, color = "gray80"),
          plot.title = element_text(face = "bold")) +
    scale_color_manual(values = c("Day" = "#FFC107", "Night" = "#303F9F", "Twilight" = "#7B1FA2"))
  
  # Return both plot and data
  return(list(plot = p, data = results))
}

# Create plots
state_road_rss <- plot_time_rss(model_glmm3.0.1, steps3, road_type = "state")
local_road_rss <- plot_time_rss(model_glmm3.0.1, steps3, road_type = "local")

# Display plots
state_road_rss$plot
local_road_rss$plot

# To arrange both plots side by side
library(gridExtra)
grid.arrange(state_road_rss$plot, local_road_rss$plot, ncol = 2)

```
```{r more visualisations}
# 1. Basic calculation function for time-based models
calculate_time_predictions <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients
  coefs <- fixef(model)$cond
  main_coef <- coefs[road_var]
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # For each time category
  time_cats <- c("Day", "Night", "Twilight")
  all_predictions <- data.frame()
  
  for (time_cat in time_cats) {
    # Calculate effect for this time category
    if (time_cat == "Day") {
      effect <- main_coef
    } else {
      interaction_name <- paste0(road_var, ":factor(time_category)", time_cat)
      if (interaction_name %in% names(coefs)) {
        effect <- main_coef + coefs[interaction_name]
      } else {
        effect <- main_coef
      }
    }
    
    # Calculate linear predictor
    linear_pred <- scaled_seq * effect
    
    # Calculate selection strength and probability
    rss <- exp(linear_pred)
    prob <- rss / (rss + 10)  # For 10 available steps
    
    # Store results
    results <- data.frame(
      distance = dist_seq,
      rss = rss,
      probability = prob,
      time_category = time_cat
    )
    
    all_predictions <- rbind(all_predictions, results)
  }
  
  return(all_predictions)
}

# 2. Simple plot function for time-based models
plot_time_predictions <- function(predictions, road_type = "state", plot_type = "probability") {
  # Set up plot parameters
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  time_colors <- c("Day" = "#FFC107", "Night" = "#303F9F", "Twilight" = "#7B1FA2")
  
  # Create the right type of plot
  if (plot_type == "probability") {
    y_var <- "probability"
    y_label <- "Selection Probability"
    title <- paste0("Moose Selection Probability vs. Distance from ", road_label)
    
    p <- ggplot(predictions, aes(x = distance, y = probability, color = time_category)) +
      geom_line(size = 1.2) +
      geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
      annotate("text", x = 100, y = 1/11 * 1.05, 
               label = "Baseline (1/11)", hjust = 0, color = "gray50", size = 3)
    
  } else {  # RSS plot
    y_var <- "rss"
    y_label <- "Relative Selection Strength"
    title <- paste0("Moose Selection Relative to Distance from ", road_label)
    
    # Normalize to distance = 0 for each time category
    predictions <- predictions %>%
      group_by(time_category) %>%
      mutate(rss_relative = rss / rss[distance == min(distance)]) %>%
      ungroup()
    
    p <- ggplot(predictions, aes(x = distance, y = rss_relative, color = time_category)) +
      geom_line(size = 1.2)
  }
  
  # Finish plot formatting
  p <- p +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = y_label,
         title = title,
         subtitle = "By time of day",
         color = "Time of Day") +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      panel.grid.minor = element_blank(),
      panel.border = element_rect(fill = NA, color = "gray80"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = time_colors)
  
  return(p)
}

# 3. Basic calculation function for season-based models
calculate_season_predictions <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients
  coefs <- fixef(model)$cond
  main_coef <- coefs[road_var]
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # For each season category
  season_cats <- c("Spring", "Summer", "Winter")
  all_predictions <- data.frame()
  
  for (season_cat in season_cats) {
    # Calculate effect for this season
    if (season_cat == "Spring") {
      effect <- main_coef
    } else {
      interaction_name <- paste0(road_var, ":factor(season)", season_cat)
      if (interaction_name %in% names(coefs)) {
        effect <- main_coef + coefs[interaction_name]
      } else {
        effect <- main_coef
      }
    }
    
    # Calculate linear predictor
    linear_pred <- scaled_seq * effect
    
    # Calculate selection strength and probability
    rss <- exp(linear_pred)
    prob <- rss / (rss + 10)  # For 10 available steps
    
    # Store results
    results <- data.frame(
      distance = dist_seq,
      rss = rss,
      probability = prob,
      season = season_cat
    )
    
    all_predictions <- rbind(all_predictions, results)
  }
  
  return(all_predictions)
}

# 4. Simple plot function for season-based models
plot_season_predictions <- function(predictions, road_type = "state", plot_type = "probability") {
  # Set up plot parameters
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  season_colors <- c("Spring" = "#4CAF50", "Summer" = "#FF9800", "Winter" = "#2196F3")
  
  # Create the right type of plot
  if (plot_type == "probability") {
    y_var <- "probability"
    y_label <- "Selection Probability"
    title <- paste0("Moose Selection Probability vs. Distance from ", road_label)
    
    p <- ggplot(predictions, aes(x = distance, y = probability, color = season)) +
      geom_line(size = 1.2) +
      geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
      annotate("text", x = 100, y = 1/11 * 1.05, 
               label = "Baseline (1/11)", hjust = 0, color = "gray50", size = 3)
    
  } else {  # RSS plot
    y_var <- "rss"
    y_label <- "Relative Selection Strength"
    title <- paste0("Moose Selection Relative to Distance from ", road_label)
    
    # Normalize to distance = 0 for each season
    predictions <- predictions %>%
      group_by(season) %>%
      mutate(rss_relative = rss / rss[distance == min(distance)]) %>%
      ungroup()
    
    p <- ggplot(predictions, aes(x = distance, y = rss_relative, color = season)) +
      geom_line(size = 1.2)
  }
  
  # Finish plot formatting
  p <- p +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = y_label,
         title = title,
         subtitle = "By season",
         color = "Season") +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      panel.grid.minor = element_blank(),
      panel.border = element_rect(fill = NA, color = "gray80"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = season_colors)
  
  return(p)
}

# 5. Basic calculation function for models without interactions
calculate_basic_predictions <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients
  coefs <- fixef(model)$cond
  effect <- coefs[road_var]
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Calculate linear predictor
  linear_pred <- scaled_seq * effect
  
  # Calculate selection strength and probability
  rss <- exp(linear_pred)
  prob <- rss / (rss + 10)  # For 10 available steps
  
  # Store results
  results <- data.frame(
    distance = dist_seq,
    rss = rss,
    probability = prob
  )
  
  return(results)
}

# 6. Simple plot function for models without interactions
plot_basic_predictions <- function(predictions, road_type = "state", plot_type = "probability") {
  # Set up plot parameters
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  
  # Create the right type of plot
  if (plot_type == "probability") {
    y_var <- "probability"
    y_label <- "Selection Probability"
    title <- paste0("Moose Selection Probability vs. Distance from ", road_label)
    
    p <- ggplot(predictions, aes(x = distance, y = probability)) +
      geom_line(size = 1.2, color = "#1976D2") +
      geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
      annotate("text", x = 100, y = 1/11 * 1.05, 
               label = "Baseline (1/11)", hjust = 0, color = "gray50", size = 3)
    
  } else {  # RSS plot
    y_var <- "rss"
    y_label <- "Relative Selection Strength"
    title <- paste0("Moose Selection Relative to Distance from ", road_label)
    
    # Normalize to distance = 0
    predictions$rss_relative <- predictions$rss / predictions$rss[1]
    
    p <- ggplot(predictions, aes(x = distance, y = rss_relative)) +
      geom_line(size = 1.2, color = "#1976D2")
  }
  
  # Finish plot formatting
  p <- p +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = y_label,
         title = title) +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      panel.border = element_rect(fill = NA, color = "gray80"),
      plot.title = element_text(face = "bold")
    )
  
  return(p)
}


# 1. Time-based model plots (model_glmm3.0.1)
# State roads
state_time_preds <- calculate_time_predictions(model_glmm3.0.1, steps3, "state_d")
state_time_plot <- plot_time_predictions(state_time_preds, "state", "probability")
state_time_plot

# Local roads 
local_time_preds <- calculate_time_predictions(model_glmm3.0.1, steps3, "local_d")
local_time_plot <- plot_time_predictions(local_time_preds, "local", "probability")
local_time_plot

# 2. Season-based model plots (model_glmm2.0)
# State roads
state_season_preds <- calculate_season_predictions(model_glmm2.0, steps3, "state_d")
state_season_plot <- plot_season_predictions(state_season_preds, "state", "probability")
state_season_plot

# Local roads
local_season_preds <- calculate_season_predictions(model_glmm2.0, steps3, "local_d")
local_season_plot <- plot_season_predictions(local_season_preds, "local", "probability")
local_season_plot

# 3. Basic model plots (model_glmm1.1.1)
# State roads
state_basic_preds <- calculate_basic_predictions(model_glmm1.1.1, steps3, "state_d")
state_basic_plot <- plot_basic_predictions(state_basic_preds, "state", "probability")
state_basic_plot

# Local roads
local_basic_preds <- calculate_basic_predictions(model_glmm1.1.1, steps3, "local_d")
local_basic_plot <- plot_basic_predictions(local_basic_preds, "local", "probability")
local_basic_plot

# You can also create RSS plots by changing the plot_type parameter
state_time_rss <- plot_time_predictions(state_time_preds, "state", "rss")
state_time_rss



# Check if your model and data objects are still valid
class(model_glmm3.0.1)
class(steps3)

# Check if state_d is properly scaled
head(steps3$state_d)
attributes(steps3$state_d)  # Should show scaled:center and scaled:scale

```
```{r checking CI ways}

# Add confidence intervals to the calculation function
calculate_time_predictions_with_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  main_coef <- coefs[road_var]
  main_se <- sqrt(diag(vcov_matrix)[road_var])
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # For each time category
  time_cats <- c("Day", "Night", "Twilight")
  all_predictions <- data.frame()
  
  for (time_cat in time_cats) {
    # Calculate effect and SE for this time category
    if (time_cat == "Day") {
      effect <- main_coef
      effect_se <- main_se
    } else {
      interaction_name <- paste0(road_var, ":factor(time_category)", time_cat)
      if (interaction_name %in% names(coefs)) {
        effect <- main_coef + coefs[interaction_name]
        # Calculate combined SE
        interaction_se <- sqrt(diag(vcov_matrix)[interaction_name])
        # Check if covariance is available
        if(road_var %in% rownames(vcov_matrix) && interaction_name %in% colnames(vcov_matrix)) {
          covar <- vcov_matrix[road_var, interaction_name]
        } else {
          covar <- 0
        }
        effect_se <- sqrt(main_se^2 + interaction_se^2 + 2*covar)
      } else {
        effect <- main_coef
        effect_se <- main_se
      }
    }
    
    # Calculate linear predictor and CIs
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * (abs(scaled_seq) * effect_se)
    linear_ci_upper <- linear_pred + 1.96 * (abs(scaled_seq) * effect_se)
    
    # Calculate selection strength and probability with CIs
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Store results
    results <- data.frame(
      distance = dist_seq,
      rss = rss,
      rss_lower = rss_lower,
      rss_upper = rss_upper,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      time_category = time_cat
    )
    
    all_predictions <- rbind(all_predictions, results)
  }
  
  return(all_predictions)
}

# Faceted plot - one panel per time period
plot_time_predictions_facet <- function(predictions, road_type = "state") {
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  time_colors <- c("Day" = "#FFC107", "Night" = "#303F9F", "Twilight" = "#7B1FA2")
  
  p <- ggplot(predictions, aes(x = distance, y = probability, color = time_category)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = time_category), 
                alpha = 0.3, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ time_category, nrow = 1) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "With 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 12, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = time_colors) +
    scale_fill_manual(values = time_colors)
  
  return(p)
}


# Calculate predictions with confidence intervals
state_preds_ci <- calculate_time_predictions_with_ci(model_glmm3.0.1, steps3, "state_d")

plot2 <- plot_time_predictions_facet(state_preds_ci, "state")

plot2

```
```{r crossing model visualisation ...}

# Calculate RSS values for each landuse type and crossing status
landuse_levels <- levels(steps3$landuse_factor)

# Create a data frame to store results
rss_data <- data.frame(
  landuse = rep(landuse_levels, each = 2),
  crossing = rep(c("No", "Yes"), times = length(landuse_levels)),
  stringsAsFactors = FALSE
)

# Get coefficients from the model
coefs <- fixef(model_glmm_local)$cond

# Calculate linear predictor for each combination
rss_data$linear_pred <- 0  # Initialize

for (i in 1:nrow(rss_data)) {
  land <- rss_data$landuse[i]
  cross <- rss_data$crossing[i] == "Yes"
  
  # Start with intercept
  pred <- coefs["(Intercept)"]
  
  # Add landuse effect if not reference level (Coniferous)
  if (land != "Coniferous") {
    pred <- pred + coefs[paste0("landuse_factor", land)]
  }
  
  # Add crossing effect and interaction if crossing=Yes
  if (cross) {
    pred <- pred + coefs["crosses_localTRUE"]
    
    # Add interaction if not reference level
    if (land != "Coniferous") {
      interaction_term <- paste0("crosses_localTRUE:landuse_factor", land)
      if (interaction_term %in% names(coefs)) {
        pred <- pred + coefs[interaction_term]
      }
    }
  }
  
  rss_data$linear_pred[i] <- pred
}

# Convert to RSS (relative to no crossing in coniferous)
reference_value <- rss_data$linear_pred[rss_data$landuse == "Coniferous" & 
                                      rss_data$crossing == "No"]
rss_data$rss <- exp(rss_data$linear_pred - reference_value)

# Add jitter for visualization
set.seed(123)
rss_data$x_jitter <- as.numeric(factor(rss_data$crossing)) + 
                   runif(nrow(rss_data), -0.1, 0.1)
rss_data$y_jitter <- rss_data$rss + runif(nrow(rss_data), -0.02, 0.02)


ggplot(rss_data, aes(x = x_jitter, y = y_jitter, shape = landuse, color = landuse)) +
  geom_point(size = 3) +
  scale_x_continuous(breaks = c(1, 2), labels = c("No", "Yes"), 
                    name = "# of crossings") +
  scale_y_continuous(name = "Relative Selection Strength") +
  ggtitle("Relative Selection Strength by Landuse Type and Local Road Crossing") +
  theme_minimal() +
  theme(
    legend.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold", size = 12)
  )




```

```{r joining CI and RSS visualisations}

# 1. Function to calculate time predictions with confidence intervals
calculate_time_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  main_coef <- coefs[road_var]
  main_se <- sqrt(diag(vcov_matrix)[road_var])
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # For each time category
  time_cats <- c("Day", "Night", "Twilight")
  all_predictions <- data.frame()
  
  for (time_cat in time_cats) {
    # Calculate effect and SE for this time category
    if (time_cat == "Day") {
      effect <- main_coef
      effect_se <- main_se
    } else {
      interaction_name <- paste0(road_var, ":factor(time_category)", time_cat)
      if (interaction_name %in% names(coefs)) {
        effect <- main_coef + coefs[interaction_name]
        # Calculate combined SE
        interaction_se <- sqrt(diag(vcov_matrix)[interaction_name])
        # Check if covariance is available
        if(road_var %in% rownames(vcov_matrix) && interaction_name %in% colnames(vcov_matrix)) {
          covar <- vcov_matrix[road_var, interaction_name]
        } else {
          covar <- 0
        }
        effect_se <- sqrt(main_se^2 + interaction_se^2 + 2*covar)
      } else {
        effect <- main_coef
        effect_se <- main_se
      }
    }
    
    # Calculate linear predictor and CIs
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * (abs(scaled_seq) * effect_se)
    linear_ci_upper <- linear_pred + 1.96 * (abs(scaled_seq) * effect_se)
    
    # Calculate selection strength and probability with CIs
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Create results data frame
    time_results <- data.frame(
      distance = dist_seq,
      rss = rss,
      rss_lower = rss_lower,
      rss_upper = rss_upper,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      time_category = time_cat
    )
    
    # Add to all predictions
    all_predictions <- rbind(all_predictions, time_results)
  }
  
  return(all_predictions)
}

# 2. Function to calculate season predictions with confidence intervals
calculate_season_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  main_coef <- coefs[road_var]
  main_se <- sqrt(diag(vcov_matrix)[road_var])
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Get all season levels and reference level
  all_seasons <- levels(data$season)
  ref_level <- all_seasons[1]
  
  # For each season
  all_predictions <- data.frame()
  
  for (season_cat in all_seasons) {
    # Calculate effect and SE for this season
    if (season_cat == ref_level) {
      effect <- main_coef
      effect_se <- main_se
    } else {
      interaction_name <- paste0(road_var, ":factor(season)", season_cat)
      if (interaction_name %in% names(coefs)) {
        effect <- main_coef + coefs[interaction_name]
        # Calculate combined SE
        interaction_se <- sqrt(diag(vcov_matrix)[interaction_name])
        # Check if covariance is available
        if(road_var %in% rownames(vcov_matrix) && interaction_name %in% colnames(vcov_matrix)) {
          covar <- vcov_matrix[road_var, interaction_name]
        } else {
          covar <- 0
        }
        effect_se <- sqrt(main_se^2 + interaction_se^2 + 2*covar)
      } else {
        effect <- main_coef
        effect_se <- main_se
      }
    }
    
    # Calculate linear predictor and CIs
    linear_pred <- scaled_seq * effect
    linear_ci_lower <- linear_pred - 1.96 * (abs(scaled_seq) * effect_se)
    linear_ci_upper <- linear_pred + 1.96 * (abs(scaled_seq) * effect_se)
    
    # Calculate selection strength and probability with CIs
    rss <- exp(linear_pred)
    rss_lower <- exp(linear_ci_lower)
    rss_upper <- exp(linear_ci_upper)
    
    prob <- rss / (rss + 10)
    prob_lower <- rss_lower / (rss_lower + 10)
    prob_upper <- rss_upper / (rss_upper + 10)
    
    # Store results
    season_results <- data.frame(
      distance = dist_seq,
      rss = rss,
      rss_lower = rss_lower,
      rss_upper = rss_upper,
      probability = prob,
      prob_lower = prob_lower,
      prob_upper = prob_upper,
      season = season_cat
    )
    
    all_predictions <- rbind(all_predictions, season_results)
  }
  
  return(all_predictions)
}

# 3. Function to calculate basic predictions with confidence intervals
calculate_basic_ci <- function(model, data, road_var, max_dist = 2000) {
  # Get scaling parameters
  var_center <- attr(data[[road_var]], "scaled:center")
  var_scale <- attr(data[[road_var]], "scaled:scale")
  
  # Extract coefficients and variance-covariance matrix
  coefs <- fixef(model)$cond
  vcov_matrix <- vcov(model)$cond
  effect <- coefs[road_var]
  effect_se <- sqrt(diag(vcov_matrix)[road_var])
  
  # Create distance sequence
  dist_seq <- seq(0, max_dist, length.out = 100)
  scaled_seq <- (dist_seq - var_center) / var_scale
  
  # Calculate linear predictor and CIs
  linear_pred <- scaled_seq * effect
  linear_ci_lower <- linear_pred - 1.96 * (abs(scaled_seq) * effect_se)
  linear_ci_upper <- linear_pred + 1.96 * (abs(scaled_seq) * effect_se)
  
  # Calculate selection strength and probability with CIs
  rss <- exp(linear_pred)
  rss_lower <- exp(linear_ci_lower)
  rss_upper <- exp(linear_ci_upper)
  
  prob <- rss / (rss + 10)
  prob_lower <- rss_lower / (rss_lower + 10)
  prob_upper <- rss_upper / (rss_upper + 10)
  
  # Store results
  results <- data.frame(
    distance = dist_seq,
    rss = rss,
    rss_lower = rss_lower,
    rss_upper = rss_upper,
    probability = prob,
    prob_lower = prob_lower,
    prob_upper = prob_upper
  )
  
  return(results)
}

# 4. Plot time predictions with facets
plot_time_facet <- function(predictions, road_type = "state") {
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  time_colors <- c("Day" = "#FFC107", "Night" = "#303F9F", "Twilight" = "#7B1FA2")
  
  p <- ggplot(predictions, aes(x = distance, y = probability, color = time_category)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = time_category), 
                alpha = 0.3, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ time_category, nrow = 1) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "By time of day with 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 12, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = time_colors) +
    scale_fill_manual(values = time_colors)
  
  return(p)
}

# 5. Plot season predictions with facets
plot_season_facet <- function(predictions, road_type = "state") {
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  season_colors <- c("Winter" = "#2196F3", "Spring" = "#4CAF50", "Summer" = "#FF9800")
  
  p <- ggplot(predictions, aes(x = distance, y = probability, color = season)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = season), 
                alpha = 0.3, color = NA) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    facet_wrap(~ season, nrow = 1) +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "By season with 95% confidence intervals") +
    theme_minimal() +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(size = 12, face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    scale_color_manual(values = season_colors) +
    scale_fill_manual(values = season_colors)
  
  return(p)
}

# 6. Plot basic predictions
plot_basic <- function(predictions, road_type = "state") {
  road_label <- ifelse(road_type == "state", "State Roads", "Local Roads")
  
  p <- ggplot(predictions, aes(x = distance, y = probability)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper), 
                alpha = 0.3, fill = "#1976D2") +
    geom_line(size = 1.2, color = "#1976D2") +
    geom_hline(yintercept = 1/11, linetype = "dashed", color = "gray50") +
    labs(x = paste0("Distance to ", road_label, " (m)"),
         y = "Selection Probability",
         title = paste0("Moose Selection Probability vs. Distance from ", road_label),
         subtitle = "With 95% confidence intervals") +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      panel.border = element_rect(fill = NA, color = "gray80"),
      plot.title = element_text(face = "bold")
    )
  
  return(p)
}


# Create plots for time model (model_glmm3.0.1)
# State roads
state_time_preds <- calculate_time_ci(model_glmm3.0.1, steps3, "state_d")
state_time_plot <- plot_time_facet(state_time_preds, "state")

# Local roads
local_time_preds <- calculate_time_ci(model_glmm3.0.1, steps3, "local_d")
local_time_plot <- plot_time_facet(local_time_preds, "local")

# Create plots for season model (model_glmm2.0)
# State roads
state_season_preds <- calculate_season_ci(model_glmm2.0, steps3, "state_d")
state_season_plot <- plot_season_facet(state_season_preds, "state")

# Local roads
local_season_preds <- calculate_season_ci(model_glmm2.0, steps3, "local_d")
local_season_plot <- plot_season_facet(local_season_preds, "local")

# Create plots for basic model (model_glmm1.1.1)
# State roads
state_basic_preds <- calculate_basic_ci(model_glmm1.1.1, steps3, "state_d")
state_basic_plot <- plot_basic(state_basic_preds, "state")

# Local roads
local_basic_preds <- calculate_basic_ci(model_glmm1.1.1, steps3, "local_d")
local_basic_plot <- plot_basic(local_basic_preds, "local")

# Display individual plots
state_time_plot
local_time_plot
state_season_plot
local_season_plot
state_basic_plot
local_basic_plot

# Arrange plots in a grid if needed
time_plots <- grid.arrange(state_time_plot, local_time_plot, 
                         nrow = 2, top = "Moose Road Selection by Time of Day")

season_plots <- grid.arrange(state_season_plot, local_season_plot,
                           nrow = 2, top = "Moose Road Selection by Season")

basic_plots <- grid.arrange(state_basic_plot, local_basic_plot,
                          nrow = 2, top = "Moose Road Selection - Basic Model")

# Save plots if needed
# ggsave("time_plots.png", time_plots, width = 12, height = 8)
# ggsave("season_plots.png", season_plots, width = 12, height = 8)
# ggsave("basic_plots.png", basic_plots, width = 12, height = 8)

```


```{r Stefanie example, not accessible currently.. just paste}
#'---
#'title: RSF and SSF analysis of fisher 
#'author: "S. Muff, J. Signer, J. Fieberg"
#'date: "r format(Sys.time(), '%d %B, %Y')"
#'output:
#'  html_document:
#'    toc: yes
#'---

#+ include = FALSE
knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE)

#' ## Purpose
#' The purpose of this document is to illustrate how a simple RSF and SSF with random effects can be fitted to tracking data. We use a data set containing fisher locations from:
#' 
#' - LaPoint, S., Gallery, P., Wikelski, M. and Kays, R. (2013). Animal behavior, cost-based corridor models, and real corridors. Landscape Ecology, 28, 1615-1630.
#' 

#' ## Load libraries and prepare data
#+ echo=TRUE, message=FALSE, warning=FALSE
library(glmmTMB)
library(INLA)
library(tidyverse)
library(raster)
library(survival)
library(TwoStepCLogit)
library(amt)

#' First load the fisher data (this is the data as it was downloaded from movebank).
#' We simplified the fisher data slightly, by running the following code prior to upload the data (to save space). This code is not needed, unless you download the original data from: https://www.datarepository.movebank.org/handle/10255/move.330.
#+ eval=FALSE
dat <- read_csv("Martes pennanti LaPoint New York.csv") %>% 
  filter(!is.na(location-lat)) %>% 
  select(x = location-long, y = location-lat, 
         t = timestamp, id = tag-local-identifier) %>% 
  filter(id %in% c(1465, 1466, 1072, 1078, 1016, 1469))
write_csv(dat, "Fisher_analysis/fisher_data.csv")

#' Now lets start by reading in the simplified fisher data

dat <- read_csv("fisher_data.csv")

#' Include sex of each animal and create tracks with an appropriate coordinate reference system using the amt package
dat_all <- dat %>% nest(-id) 
dat_all$sex <- c("f", "f", "f", "m", "m", "m")
dat_all <- dat_all %>% 
  mutate(trk = map(data, function(d) {
    make_track(d, x, y, t, crs = sp::CRS("+init=epsg:4326")) %>% 
      transform_coords(sp::CRS("+init=epsg:5070"))
  }))

#' Summarize sampling rates, 
dat_all %>% mutate(sr = lapply(trk, summarize_sampling_rate)) %>% 
  select(id, sr) %>% unnest

#' 10 minutes seems to appropriate for all animals.
#' Resample the track to 10 minutes with a tolerance of 2 minutes.

dat1 <- dat_all %>% mutate(dat_clean = map(trk, ~ {
  .x %>% track_resample(rate = minutes(10), tolerance = seconds(120))
  }))

#' Read in the landuse raster and reclassify to two categories (wet forests and other).
landuse <- raster("landuse_study_area.tif")
wet_forests <- landuse %in% c(90, 95)
names(wet_forests) <- "forest"

#' # Resource Selection Functions (RSF)
#' 
#' ## Data development for RSF
#' 
#' Now start with an RSF by creating random points per animal and extract the covariates for the observed and random points.

dat_rsf <- dat1 %>% mutate(rp = map(dat_clean, ~ .x %>% random_points() %>% 
      extract_covariates(wet_forests))) %>% 
  select(id, rp) %>%  unnest()
#' Change id column, to 1:6
dat_rsf$id <- as.numeric(factor(dat_rsf$id))

#' Make response numeric (required for INLA)
dat_rsf$y <- as.numeric(dat_rsf$case_)

#' We use a weighted likelihood for to fit the RSF. To this end, we need to create a variable for the weights, where used points (case_ = TRUE) keep weight 1, and available points (case_ = FALSE) obtain a large weight $W$ (here $W=1000$):
#+ echo=TRUE, message=FALSE
dat_rsf$weight <- 1000^(1 - dat_rsf$case_)

#' ## Mixed RSFs
#' 
#' ### glmmTMB()
#' 
#' 
#' As explained in the manuscript (Section 3.4), we recommend to manually fix the variance of the random intercept at a large value. This can be done in glmmTMB() by first setting up the model, but do not yet fit it:
#+ echo=TRUE, message=FALSE,cache=TRUE
fisher.tmp <- glmmTMB(case_ ~ forest + (1|id) + (0 + forest |id) , family=binomial(), data = dat_rsf,
                         doFit=FALSE, weights = weight)


#' Then fix the standard deviation of the first random term, which is the (1|id) component  in the above model equation. We use $\sigma=10^3$, which corresponds to a variance of $10^6$:
#+ echo=TRUE, message=FALSE,cache=TRUE
fisher.tmp$parameters$theta[1] <- log(1e3)


#' We need to tell glmmTMB not to change the first entry of the vector of variances, and give all other variances another indicator to make sure they can be freely estimated:
#+ echo=TRUE, message=FALSE,cache=TRUE
fisher.tmp$mapArg <- list(theta=factor(c(NA, 1)))

#' Then fit the model and look at the results:
#+ echo=TRUE, message=FALSE, cache=TRUE 
fisher.rsf <- glmmTMB:::fitTMB(fisher.tmp)
summary(fisher.rsf)


#' ###  INLA 
#'
#' Let us now carry the analysis with random intercept $\mathsf{N}(0,\sigma_{id}^2)$ and fixed variance $\sigma_{id}^2=10^6$ using INLA. A peculiarity of INLA is that the same variable cannot be used more than once. So for ID we need to generate a new (but identical) variable
#+ echo=TRUE, message=FALSE
dat_rsf$id1 <-dat_rsf$id

#' For the fixed effects we use the INLA (default) priors $\beta \sim \mathsf{N}(0,\sigma_\beta^2)$ with $\sigma_\beta^2=10^4$. The precisions of the priors are thus set to:
#+ echo=TRUE, message=FALSE
prec.beta.forest  <- 1e-4  

#' We now store the INLA formula with the fixed effects forest, plus two random effects, namely one for the individual-specific intercept and one for the individual-specific slope for forest. Note that the precision (thus $1/\sigma^2$) for id is fixed (fixed=TRUE) at the value of $10^{-6}$ (thus the variance is fixed at $10^6$). The other precision is given a PC(1,0.05) prior:
#+ echo=TRUE, message=FALSE
formula.inla <- y ~  forest + 
  f(id, model="iid", hyper=list(theta = list(initial=log(1e-6),fixed=TRUE))) +
  f(id1,forest,values=1:6,model="iid",
    hyper=list(theta=list(initial=log(1),fixed=F,prior="pc.prec",param=c(1,0.05)))) 


#' The actual INLA call is then given as follows:
#+  echo=TRUE, message=FALSE, cache=TRUE
inla.setOption(enable.inla.argument.weights=TRUE)
fisher.inla  <- inla(formula.inla, family ="binomial", data=dat_rsf, weights=dat_rsf$weight,
                        control.fixed = list(
                          mean = 0,
                          prec = list(forest = prec.beta.forest)
                       )
)



#' The summary for the posterior distribution of the fixed effects is given as follows:
#+ echo=TRUE
fisher.inla$summary.fixed


#' Since variances are parameterized and treated as precisions, the summary of the respective posterior distributions is given for the precisions:
#+ echo=TRUE
fisher.inla$summary.hyperpar


#' Source R functions for calculating posterior means 
#' and medians of the precisions.
source("inla_emarginal.R")
source("inla_mmarginal.R")
inla_emarginal(fisher.inla)
inla_mmarginal(fisher.inla)



#' # Step-Selection Function (SSF)
#' 
#' ## Data development for step-selection function
#' 
#' First we need to prepare the data. We need to pair each observed point with 10 random points and extract the covariate value at the end point of each step.

#+ warning = FALSE
dat_ssf <- dat1 %>% 
  mutate(stps = map(dat_clean, ~ .x %>% steps_by_burst() %>% 
                      random_steps() %>% extract_covariates(wet_forests))) %>% 
  select(id, stps) %>% unnest() %>% 
  mutate(
    y = as.numeric(case_),
    id = as.numeric(factor(id)), 
    step_id = paste0(id, step_id_, sep = "-"))
dat_ssf


#' ## Mixed SSFs 

#' ### 2StepCLogit 

#' The two-step procedure with independent random effect (D="UN(1)"):
r.Twostep <-  Ts.estim(formula = y ~ forest + strata(step_id) + 
                     cluster(id), data = dat_ssf, random = ~ forest,
                   all.m.1=F, D="UN(1)") 

#' Slope estimates and standard errors
r.Twostep$beta
r.Twostep$se

#' Variance estimates
r.Twostep$D

#' ### glmmTMB


#' ## Session Info
#'
devtools::session_info()


#'---
#' title: Habitat selection of otters (an SSF analysis)
#' author: "S. Muff, J. Signer, J. Fieberg"
#' date: "r format(Sys.time(), '%d %B, %Y')"
#' output:
#'   html_document: 
#'     toc: true
#'---
#'
#+ include = FALSE
knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE)
#'  
#' **Purpose**: This code replicates the analysis presented in Muff, Signer, Fieberg (2019) Section 4.2 "Habitat selection of otters: an SSF analysis".
#'

#' ## Load libraries and read in data
#+ warning=FALSE, message=FALSE
library(survival)
library(TwoStepCLogit)
library(INLA)
library(glmmTMB)
options(width=150)
dat <-  read.csv("d_otter.csv")
str(dat)

#' NAT1, REST1 and STAU1 are the three factor levels of the factor variable habitat type, encoded as dummy variables, where
#'
#' - NAT1: natural habitat (reference category)
#' - REST1: residual water
#' - STAU1: a reservoir
#'
#' Further, the two continuous variables in the model are:
#' 
#' - Sohlbrei: the river width
#' - Breaks_Dis: step length
#' 
#' Finally, Loc is the binary response variable that indicates if a habitat point was used (1) or available (0).
#'
#' ### Some data manipulation:

#' Add numerical variable for animals:
dat$ANIMAL_ID <- as.numeric(as.factor(dat$NA_ANIMAL))

#' Stratum ID is given as "NA_ID" in the data; 
#' It is easier to have sequential enumeration, so let's generate a new stratum-ID variable str_ID:
d.map <- data.frame(NA_ID=unique(dat$NA_ID),str_ID=1:length(unique(dat$NA_ID)))
dat$str_ID <- d.map[match(dat$NA_ID,d.map$NA_ID),"str_ID"]
dat <- dat[order(dat$str_ID),]

#' Scale and center the two continuous variables river width (Sohlenbrei) and step length (Breaks_Dis)
dat$Sohlenbrei <- scale(dat$Sohlenbrei)
dat$Breaks_Dis <- scale(dat$Breaks_Dis)


#' ## Fixed effects models 
 
#' ### clogit
r.clogit <- clogit(Loc ~ STAU1 + REST1 + Sohlenbrei + Breaks_Dis  
                   +   strata(str_ID), data=dat) 

summary(r.clogit)$coef

```

